machine learning in automated text categorization .
the automated categorization ( or classification ) of texts into predefined categories has witnessed a booming interest in the last 10 years , due to the increased availability of documents in digital form and the ensuing need to organize them .
in the research community the dominant approach to this problem is based on machine learning techniques : a general inductive process automatically builds a classifier by learning , from a set of preclassified documents , the characteristics of the categories .
the advantages of this approach over the knowledge engineering approach ( consisting in the manual definition of a classifier by domain experts ) are a very good effectiveness , considerable savings in terms of expert labor power , and straightforward portability to different domains .
this survey discusses the main approaches to text categorization that fall within the machine learning paradigm .
we will discuss in detail issues pertaining to three different problems , namely , document representation , classifier construction , and classifier evaluation .
introduction .
in the last 10 years content-based document management tasks ( collectively known as information retrieval ir ) have gained a prominent status in the information systems field , due to the increased availability of documents in digital form and the ensuing need to access them in flexible ways .
text categorization ( tc a.k.a. text classification , or topic spotting ) , the activity of labeling natural language texts with thematic categories from a predefined set , is one such task .
tc dates back to the early 60s , but only in the early 90s did it become a major subfield of the information systems discipline , thanks to increased applicative interest and to the availability of more powerful hardware .
tc is now being applied in many contexts , ranging from document indexing based on a controlled vocabulary , to document filtering , automated metadata generation , word sense disambiguation , population of hierarchical catalogues of web resources , and in general any application requiring document organization or selective and adaptive document dispatching .
until the late 80s the most popular approach to tc , at least in the operational ( i.e. , real-world applications ) community , was a knowledge engineering ( ke ) one , consisting in manually defining a set of rules encoding expert knowledge on how to classify documents under the given categories .
in the 90s this approach has increasingly lost popularity ( especially in the research community ) in favor of the machine learning ( ml ) paradigm , according to which a general inductive process automatically builds an automatic text classifier by learning , from a set of preclassified documents , the characteristics of the categories of interest .
the advantages of this approach are an accuracy comparable to that achieved by human experts , and a considerable savings in terms of expert labor power , since no intervention from either knowledge engineers or domain experts is needed for the construction of the classifier or for its porting to a different set of categories .
it is the ml approach to tc that this paper concentrates on .
current-day tc is thus a discipline at the crossroads of ml and ir , and as such it shares a number of characteristics with other tasks such as information / knowledge extraction from texts and text mining [ knight 1999 ; pazienza 1997 ] .
there is still considerable debate on where the exact border between these disciplines lies , and the terminology is still evolving .
text mining is increasingly being used to denote all the tasks that , by analyzing large quantities of text and detecting usage patterns , try to extract probably useful ( although only probably correct ) information .
according to this view , tc is an instance of text mining .
tc enjoys quite a rich literature now , but this is still fairly scattered.1 although two international journals have devoted special issues to this topic [ joachims and sebastiani 2002 ; lewis and hayes 1994 ] , there are no systematic treatments of the subject : there are neither textbooks nor journals entirely devoted to tc yet , and manning and sch utze [ 1999 , chapter 16 ] is the only chapter-length treatment of the subject .
as a note , we should warn the reader that the term automatic text classification has sometimes been used in the literature to mean things quite different from the ones discussed here .
aside from ( i ) the automatic assignment of documents to a predefined set of categories , which is the main topic of this paper , the term has also been used to mean ( ii ) the automatic identification of such a set of categories ( e.g. , borko and bernick [ 1963 ] ) , or ( iii ) the automatic identification of such a set of categories and the grouping of documents under them ( e.g. , merkl [ 1998 ] ) , a task usually called text clustering , or ( iv ) any activity of placing text items into groups , a task that has thus both tc and text clustering as particular instances [ manning and sch utze 1999 ] .
this paper is organized as follows .
in section 2 we formally define tc and its various subcases , and in section 3 we review its most important applications .
section 4 describes the main ideas underlying the ml approach to classification .
our discussion of text classification starts in section 5 by introducing text indexing , that is , the transformation of textual documents into a form that can be interpreted by a classifier-building algorithm and by the classifier eventually built by it .
section 6 tackles the inductive construction of a text classifier from a training set of preclassified documents .
section 7 discusses the evaluation of text classifiers .
section 8 concludes , discussing open issues and possible avenues of further research for tc .
text categorization .
a definition of text categorization .
a value of t assigned to ~ d ; , ci ) indicates a decision to file d ; under ci , while a value of f indicates a decision not to file d ; under ci .
more formally , the task is to approximate the unknown target function 4 ) ^ : d x c -- > { t , f } ( that describes how documents ought to be classified ) by means of a function 4 ) : d x c -- > { t , f } called the classifier ( aka rule , or hypothesis , or model ) such that 4 ) ^ and 4 ) coincide as much as possible .
how to precisely define and measure this coincidence ( called effectiveness ) will be discussed in section 7.1 .
from now on we will assume that : the categories are just symbolic labels , and no additional knowledge ( of a procedural or declarative nature ) of their meaning is available .
no exogenous knowledge ( i.e. , data provided for classification purposes by an external source ) is available ; therefore , classification must be accomplished on the basis of endogenous knowledge only ( i.e. , knowledge extracted from the documents ) .
in particular , this means that metadata such as , for example , publication date , document type , publication source , etc . , is not assumed to be available .
the tc methods we will discuss are thus completely general , and do not depend on the availability of special-purpose resources that might be unavailable or costly to develop .
of course , these assumptions need not be verified in operational settings , where it is legitimate to use any source of information that might be available or deemed worth developing [ diaz esteban et al. 1998 ; junker and abecker 1997 ] .
relying only on endogenous knowledge means classifying a document based solely on its semantics , and given that the semantics of a document is a sub ; ective notion , it follows that the membership of a document in a category ( pretty much as the relevance of a document to an information need in ir [ saracevic 1975 ] ) cannot be decided deterministically .
this is exemplified by the phenomenon of inter-indexer inconsistency [ cleverdon 1984 ] : when two human experts decide whether to classify document d ; under category ci , they may disagree , and this in fact happens with relatively high frequency .
a news article on clinton attending dizzy gillespie s funeral could be filed under politics , or under jazz , or under both , or even under neither , depending on the subjective judgment of the expert .
single-label versus multilabel text categorization .
different constraints may be enforced on the tc task , depending on the application .
for instance we might need that , for a given integer k , exactly k ( or < k , or > k ) elements of c be assigned to each d ; e d. the case in which exactly one category must be assigned to each d ; e d is often called the single-label ( a.k.a. nonoverlapping categories ) case , while the case in which any number of categories from 0 to ici may be assigned to the same d ; e d is dubbed the multilabel ( aka overlapping categories ) case .
a special case of single- label tc is binary tc , in which each d ; e d must be assigned either to category ci or to its complement ci .
from a theoretical point of view , the binary case ( hence , the single-label case , too ) is more general than the multilabel , since an algorithm for binary classification can also be used for multilabel classification : one needs only transform the problem of multilabel classification under { c1 , ... , cici } into ici independent problems of binary classification under { ci , ci } , for i = 1 , . . . , ici .
however , this requires that categories be stochastically independent of each other , that is , for any c ' , c " , the value of ^ 4 ) ( d ; , c ' ) does not depend on the value of ^ 4 ) ( d ; , c " ) and vice versa ; this is usually assumed to be the case ( applications in which this is not the case are discussed in section 3.5 ) .
the converse is not true : an algorithm for multilabel classification cannot be used for either binary or single-label classification .
in fact , given a document d ; to classify , ( i ) the classifier might attribute k > 1 categories to d ; , and it might not be obvious how to choose a most appropriate category from them ; or ( ii ) the classifier might attribute to d ; no category at all , and it might not be obvious how to choose a least inappropriate category from c. in the rest of the paper , unless explicitly mentioned , we will deal with the binary case .
there are various reasons for this : the binary case is important in itself because important tc applications , including filtering ( see section 3.3 ) , consist of binary classification problems ( e.g. , deciding whether d ; is about jazz or not ) .
in tc , most binary classification problems feature unevenly populated categories ( e.g. , much fewer documents are about jazz than are not ) and unevenly characterized categories ( e.g. , what is about jazz can be characterized much better than what is not ) .
solving the binary case also means solving the multilabel case , which is also representative of important tc applications , including automated indexing for boolean systems ( see section 3.1 ) .
most of the tc literature is couched in terms of the binary case .
most techniques for binary classification are just special cases of existing techniques for the single-label case , and are simpler to illustrate than these latter .
category-pivoted versus document-pivoted text categorization .
there are two different ways of using a text classifier .
given d ; ed , we might want to find all the ci e c under which it should be filed ( document -pivoted categorization dpc ) ; alternatively , given ci e c , we might want to find all the d ; e d that should be filed under it ( category -pivoted categorization cpc ) .
this distinction is more pragmatic than conceptual , but is important since the sets c and d might not be available in their entirety right from the start .
it is also relevant to the choice of the classifier-building method , as some of these methods ( see section 6.9 ) allow the construction of classifiers with a definite slant toward one or the other style .
dpc is thus suitable when documents become available at different moments in time , e.g. , in filtering e-mail .
cpc is instead suitable when ( i ) a new category cci + 1 may be added to an existing set c = { c1 , ... , cici 1 after a number of documents have already been classified under c , and ( ii ) these documents need to be reconsidered for classification under cici + 1 ( e.g. , larkey [ 1999 ] ) .
dpc is used more often than cpc , as the former situation is more common than the latter .
although some specific techniques apply to one style and not to the other ( e.g. , the proportional thresholding method discussed in section 6.1 applies only to cpc ) , this is more the exception than the rule : most of the techniques we will discuss allow the construction of classifiers capable of working in either mode .
hard categorization versus .
ranking categorization .
while a complete automation of the tc task requires a t or f decision for each pair ( d ; , ci ~ , a partial automation of this process might have different requirements .
for instance , given d ; ed a system might simply rank the categories in c = { c1 , ... , cici 1 according to their estimated appropriateness to d ; , without taking any hard decision on any of them .
such a ranked list would be of great help to a human expert in charge of taking the final categorization decision , since she could thus restrict the choice to the category ( or categories ) at the top of the list , rather than having to examine the entire set .
alternatively , given ci e c a system might simply rank the documents in d according to their estimated appropriateness to ci ; symmetrically , for classification under ci a human expert would just examine the top-ranked documents instead of the entire document set .
these two modalities are sometimes called category-ranking tc and document- ranking tc [ yang 1999 ] , respectively , and are the obvious counterparts of dpc and cpc .
semiautomated , interactive classification systems [ larkey and croft 1996 ] are useful especially in critical applications in which the effectiveness of a fully automated system may be expected to be significantly lower than that of a human expert .
this may be the case when the quality of the training data ( see section 4 ) is low , or when the training documents cannot be trusted to be a representative sample of the unseen documents that are to come , so that the results of a completely automatic classifier could not be trusted completely .
in the rest of the paper , unless explicitly mentioned , we will deal with hard classification ; however , many of the algorithms we will discuss naturally lend themselves to ranking tc too ( more details on this in section 6.1 ) .
applications of text categorization .
tc goes back to maron s [ 1961 ] seminal work on probabilistic text classification .
since then , it has been used for a number of different applications , of which we here briefly review the most important ones .
note that the borders between the different classes of applications listed here are fuzzy and somehow artificial , and some of these may be considered special cases of others .
other applications we do not explicitly discuss are speech categorization by means of a combination of speech recognition and tc [ myers et al. 2000 ; schapire and singer 2000 ] , multimedia document categorization through the analysis of textual captions [ sable and hatzivassiloglou 2000 ] , author identification for literary texts of unknown or disputed authorship [ forsyth 1999 ] , language identification for texts of unknown language [ cavnar and trenkle 1994 ] , automated identification of text genre [ kessler et al. 1997 ] , and automated essay grading [ larkey 1998 ] .
automatic indexing for boolean information retrieval systems .
the application that has spawned most of the early research in the field [ borko and bernick 1963 ; field 1975 ; gray and harley 1971 ; heaps 1973 ; maron 1961 ] is that of automatic document indexing for ir systems relying on a controlled dictionary , the most prominent example of which is boolean systems .
in these latter each document is assigned one or more key words or key phrases describing its content , where these key words and key phrases belong to a finite set called controlled dictionary , often consisting of a thematic hierarchical thesaurus ( e.g. , the nasa thesaurus for the aerospace discipline , or the mesh thesaurus for medicine ) .
usually , this assignment is done by trained human indexers , and is thus a costly activity .
if the entries in the controlled vocabulary are viewed as categories , text indexing is an instance of tc , and may thus be addressed by the automatic techniques described in this paper .
recalling section 2.2 , note that this application may typically require that k1 < x < k2 key words are assigned to each document , for given k1 , k2 .
document-pivoted tc is probably the best option , so that new documents may be classified as they become available .
various text classifiers explicitly conceived for document indexing have been described in the literature ; see , for example , fuhr and knorz [ 1984 ] , robertson and harding [ 1984 ] , and tzeras and hartmann [ 1993 ] .
automatic indexing with controlled dictionaries is closely related to automated metadata generation .
in digital libraries , one is usually interested in tagging documents by metadata that describes them under a variety of aspects ( e.g. , creation date , document type or format , availability , etc . ) .
some of this metadata is thematic , that is , its role is to describe the semantics of the document by means of bibliographic codes , key words or key phrases .
the generation of this metadata may thus be viewed as a problem of document indexing with controlled dictionary , and thus tackled by means of tc techniques .
document organization .
indexing with a controlled vocabulary is an instance of the general problem of document base organization .
in general , many other issues pertaining to document organization and filing , be it for purposes of personal organization or structuring of a corporate document base , may be addressed by tc techniques .
for instance , at the offices of a newspaper incoming classified ads must be , prior to publication , categorized under categories such as personals , cars for sale , real estate , etc .
newspapers dealing with a high volume of classified ads would benefit from an automatic system that chooses the most suitable category for a given ad .
other possible applications are the organization of patents into categories for making their search easier [ larkey 1999 ] , the automatic filing of newspaper articles under the appropriate sections ( e.g. , politics , home news , lifestyles , etc . ) , or the automatic grouping of conference papers into sessions .
text filtering .
text filtering is the activity of classifying a stream of incoming documents dispatched in an asynchronous way by an information producer to an information consumer [ belkin and croft 1992 ] .
a typical case is a newsfeed , where the producer is a news agency and the consumer is a newspaper [ hayes et al. 1990 ] .
in this case , the filtering system should block the delivery of the documents the consumer is likely not interested in ( e.g. , all news not concerning sports , in the case of a sports newspaper ) .
filtering can be seen as a case of single-label tc , that is , the classification of incoming documents into two disjoint categories , the relevant and the irrelevant .
additionally , a filtering system may also further classify the documents deemed relevant to the consumer into thematic categories ; in the example above , all articles about sports should be further classified according to which sport they deal with , so as to allow journalists specialized in individual sports to access only documents of prospective interest for them .
similarly , an e-mail filter might be trained to discard junk mail [ androutsopoulos et al. 2000 ; drucker et al. 1999 ] and further classify nonjunk mail into topical categories of interest to the user .
a filtering system may be installed at the producer end , in which case it must route the documents to the interested consumers only , or at the consumer end , in which case it must block the delivery of documents deemed uninteresting to the consumer .
in the former case , the system builds and updates a profile for each consumer [ liddy et al. 1994 ] , while in the latter case ( which is the more common , and to which we will refer in the rest of this section ) a single profile is needed .
a profile may be initially specified by the user , thereby resembling a standing ir query , and is updated by the system by using feedback information provided ( either implicitly or explicitly ) by the user on the relevance or nonrelevance of the delivered messages .
in the trec community [ lewis 1995c ] , this is called adaptive filtering , while the case in which no user- specified profile is available is called either routing or batch filtering , depending on whether documents have to be ranked in decreasing order of estimated relevance or just accepted / rejected .
batch filtering thus coincides with single-label tc under | c | = 2 categories ; since this latter is a completely general tc task , some authors [ hull 1994 ; hull et al.1996 ; schapire et al. 1998 ; sch utze et al. 1995 ] , somewhat confusingly , use the term filtering in place of the more appropriate term categorization .
in information science , document filtering has a tradition dating back to the 60s , when , addressed by systems of various degrees of automation and dealing with the multiconsumer case discussed above , it was called selective dissemination of information or current awareness ( see korfhage [ 1997 , chapter 6 ] ) .
the explosion in the availability of digital information has boosted the importance of such systems , which are nowadays being used in contexts such as the creation of personalized web newspapers , junk e-mail blocking , and usenet news selection .
information filtering by ml techniques is widely discussed in the literature : see amati and crestani [ 1999 ] , iyer et al. [ 2000 ] , kim et al. [ 2000 ] , tauritz et al. [ 2000 ] , and yu and lam [ 1998 ] .
word sense disambiguation .
word sense disambiguation ( wsd ) is the activity of finding , given the occurrence in a text of an ambiguous ( i.e. , polysemous or homonymous ) word , the sense of this particular word occurrence .
for instance , bank may have ( at least ) two different senses in english , as in the bank of england ( a financial institution ) or the bank of river thames ( a hydraulic engineering artifact ) .
it is thus a wsd task to decide which of the above senses the occurrence of bank in last week i borrowed some money from the bank has .
wsd is very important for many applications , including natural language processing , and indexing documents byword senses rather than by words for ir purposes .
wsd may be seen as a tc task ( see gale et al. [ 1993 ] ; escudero et al. [ 2000 ] ) once we view word occurrence contexts as documents and word senses as categories .
quite obviously , this is a single-label tc case , and one in which document-pivoted tc is usually the right choice .
wsd is just an example of the more general issue of resolving natural language ambiguities , one of the most important problems in computational linguistics .
other examples , which may all be tackled by means of tc techniques along the lines discussed for wsd , are context-sensitive spelling correction , prepositional phrase attachment , part of speech tagging , and word choice selection in machine translation ; see roth [ 1998 ] for an introduction .
hierarchical categorization of web pages .
tc has recently aroused a lot of interest also for its possible application to automatically classifying web pages , or sites , under the hierarchical catalogues hosted by popular internet portals .
when web documents are catalogued in this way , rather than issuing a query to a general- purpose web search engine a searcher may find it easier to first navigate in the hierarchy of categories and then restrict her search to a particular category of interest .
classifying web pages automatically has obvious advantages , since the manual categorization of a large enough subset of the web is infeasible .
unlike in the previous applications , it is typically the case that each category must be populated by a set of k1 < x < k2 documents .
cpc should be chosen so as to allow new categories to be added and obsolete ones to be deleted .
with respect to previously discussed tc applications , automatic web page categorization has two essential peculiarities : ( 1 ) the hypertextual nature of the documents : links are a rich source of information , as they may be understood as stating the relevance of the linked page to the linking page .
techniques exploiting this intuition in a tc context have been presented by attardi et al. [ 1998 ] , chakrabarti et al. [ 1998b ] , f urnkranz [ 1999 ] , g overt et al. [ 1999 ] , and oh et al. [ 2000 ] and experimentally compared by yang et al. [ 2002 ] .
( 2 ) the hierarchical structure of the category set : this may be used , for example , by decomposing the classification problem into a number of smaller classification problems , each corresponding to a branching decision at an internal node .
techniques exploiting this intuition in a tc context have been presented by dumais and chen [ 2000 ] , chakrabarti et al. [ 1998a ] , koller and sahami [ 1997 ] , mccallum et al. [ 1998 ] , ruiz and srinivasan [ 1999 ] , and weigend et al. [ 1999 ] .
the machine learning approach to text categorization .
in the 80s , the most popular approach ( at least in operational settings ) for the creation of automatic document classifiers consisted in manually building , by means of knowledge engineering ( ke ) techniques , an expert system capable of taking tc decisions .
the most famous example of this approach is the construe system [ hayes et al. 1990 ] , built by carnegie group for the reuters news agency .
a sample rule of the type used in construe is illustrated in figure 1 .
the drawback of this approach is the knowledge acquisition bottleneck well known from the expert systems literature .
that is , the rules must be manually defined by a knowledge engineer with the aid of a domain expert ( in this case , an expert in the membership of documents in the chosen set of categories ) : if the set of categories is updated , then these two professionals must intervene again , and if the classifier is ported to a completely different domain ( i.e. , set of categories ) , a different domain expert needs to intervene and the work has to be repeated from scratch .
on the other hand , it was originally suggested that this approach can give very good effectiveness results : hayes et al. [ 1990 ] reported a .90 breakeven result ( see section 7 ) on a subset of the reuters test collection , a figure that outperforms even the best classifiers built in the late 90s by state-of-the-art ml techniques .
however , no other classifier has been tested on the same dataset as construe , and it is not clear whether this was a randomly chosen or a favorable subset of the entire reuters collection .
as argued by yang [ 1999 ] , the results above do not allow us to state that these effectiveness results may be obtained in general .
since the early 90s , the ml approach to tc has gained popularity and has eventually become the dominant one , at least in the research community ( see mitchell [ 1996 ] for a comprehensive introduction to ml ) .
in this approach , a general inductive process ( also called the learner ) automatically builds a classifier for a category ci by observing the characteristics of a set of documents manually classified under ci or ci by a domain expert ; from these characteristics , the inductive process gleans the characteristics that a new unseen document should have in order to be classified under ci .
in ml terminology , the classification problem is an activity of supervised learning , since the learning process is supervised by the knowledge of the categories and of the training instances that belong to them.2 the advantages of the ml approach over the ke approach are evident .
the engineering effort goes toward the construction not of a classifier , but of an automatic builder of classifiers ( the learner ) .
this means that if a learner is ( as it often is ) available off-the-shelf , all that is needed is the inductive , automatic construction of a classifier from a set of manually classified documents .
the same happens if a classifier already exists and the original set of categories is updated , or if the classifier is ported to a completely different domain .
in the ml approach , the preclassified documents are then the key resource .
in the most favorable case , they are already available ; this typically happens for organizations which have previously carried out the same categorization activity manually and decide to automate the process .
the less favorable case is when no manually classified documents are available ; this typically happens for organizations that start a categorization activity and opt for an automated modality straightaway .
the ml approach is more convenient than the ke approach also in this latter case .
in fact , it is easier to manually classify a set of documents than to build and tune a set of rules , since it is easier to characterize a concept extensionally ( i.e. , to select instances of it ) than intensionally ( i.e. , to describe the concept in words , or to describe a procedure for recognizing its instances ) .
classifiers built by means of ml techniques nowadays achieve impressive levels of effectiveness ( see section 7 ) , making automatic classification a qualitatively ( and not only economically ) viable alternative to manual classification .
training set , test set , and validation set .
the documents in te cannot participate in any way in the inductive construction of the classifiers ; if this condition were not satisfied , the experimental results obtained would likely be unrealistically good , and the evaluation would thus have no scientific character [ mitchell 1996 , page 129 ] .
in an operational setting , after evaluation has been performed one would typically retrain the classifier on the entire initial corpus , in order to boost effectiveness .
in this case , the results of the previous evaluation would be a pessimistic estimate of the real performance , since the final classifier has been trained on more data than the classifier evaluated .
this is called the train-and-test approach .
an alternative is the k-fold cross- validation approach ( see mitchell [ 1996 ] , page 146 ) , in which k different classifiers 4 ) 1 , ... , 4 ) k are built by partitioning the initial corpus into k disjoint sets te1 , ... , tek and then iteratively applying the train-and-test approach on pairs ( tvi = 0 ^ tei , tei ) .
the final effectiveness figure is obtained by individually computing the effectiveness of 4 ) 1 , ... , 4 ) k , and then averaging the individual results in some way .
in both approaches , it is often the case that the internal parameters of the classifiers must be tuned by testing which values of the parameters yield the best effectiveness .
in order to make this optimization possible , in the train-and-test approach the set { d1 , ... , dltvl1 is further split into a training set tr = { d1 , ... , dltrl1 , from which the classifier is built , and a validation set va = { dltrl + 1 , . . . , dltvl1 ( sometimes called a hold-out set ) , on which the repeated tests of the classifier aimed at parameter optimization are performed ; the obvious variant may be used in the k-fold cross-validation case .
note that , for the same reason why we do not test a classifier on the documents it has been trained on , we do not test it on the documents it has been optimized on : test set and validation set must be kept separate.3 the training set generality gtr ( ci ) , validation set generality gva ( ci ) , and test set generality gte ( ci ) of ci may be defined in the obvious way .
information retrieval techniques and text categorization .
text categorization heavily relies on the basic machinery of ir .
the reason is that tc is a content-based document management task , and as such it shares many characteristics with other ir tasks such as text search .
ir techniques are used in three phases of the text classifier life cycle : ( 1 ) ir-style indexing is always performed on the documents of the initial corpus and on those to be classified during the operational phase ; ( 2 ) ir-style techniques ( such as document-request matching , query reformulation , ... ) are often used in the inductive construction of the classifiers ; ( 3 ) ir-style evaluation of the effectiveness of the classifiers is performed .
the various approaches to classification differ mostly for how they tackle ( 2 ) , although in a few cases nonstandard from now on , we will take the freedom to use the expression test document to denote any document not in the training set and validation set .
this includes thus any document submitted to the classifier in the operational phase. approaches to ( 1 ) and ( 3 ) are also used .
indexing , induction , and evaluation are the themes of sections 5 , 6 and 7 , respectively .
document indexing and dimensionality reduction .
a typical choice for ( 1 ) is to identify terms with words .
this is often called either the set of words or the bag of words approach to document representation , depending on whether weights are binary or not .
in a number of experiments [ apt e et al. 1994 ; dumais et al. 1998 ; lewis 1992a ] , it has been found that representations more sophisticated than this do not yield significantly better effectiveness , thereby confirming similar results from ir document indexing .
texts cannot be directly interpreted by a classifier or by a classifier-building algorithm .
because of this , an indexing procedure that maps a text d ; into a compact representation of its content needs to be uniformly applied to training , validation , and test documents .
the choice of a representation for text depends on what one regards as the meaningful units of text ( the problem of lexical semantics ) and the meaningful natural language rules for the combination of these units ( the problem of compositional semantics ) .
similarly to what happens in ir , in tc this latter problem is usually disregarded , 4 and a text d ; is usually represented as a vector of term weights d ~ j = ( w1 ; ... , w1t ; ) , where [ salton and buckley 1988 ] .
in particular , some authors have used phrases , rather than individual words , as indexing terms [ fuhr et al. 1991 ; sch utze et al. 1995 ; tzeras and hartmann 1993 ] , but the experimental results found to date have not been uniformly encouraging , irrespectively of whether the notion of phrase is motivated .
lewis [ 1992a ] argued that the likely reason for the discouraging results is that , although indexing languages based on phrases have superior semantic qualities , they have inferior statistical qualities with respect to word-only indexing languages : a phrase-only indexing language has more terms , more synonymous or nearly synonymous terms , lower consistency of assignment ( since synonymous terms are not assigned to the same documents ) , and lower document frequency for terms [ lewis 1992a , page 40 ] .
although his remarks are about syntactically motivated phrases , they also apply to statistically motivated ones , although perhaps to a smaller degree .
a combination of the two approaches is probably the best way to go : tzeras and hartmann [ 1993 ] obtained significant improvements by using noun phrases obtained through a combination of syntactic and statistical criteria , where a crude syntactic method was complemented by a statistical filter ( only those syntactic phrases that occurred at least three times in the positive examples of a category ci were retained ) .
it is likely that the final word on the usefulness of phrase indexing in tc has still to be told , and investigations in this direction are still being actively pursued [ caropreso et al. 2001 ; mladeni c and grobelnik 1998 ] .
as for issue ( 2 ) , weights usually range between 0 and 1 ( an exception is lewis et al. [ 1996 ] ) , and for ease of exposition we will assume they always do .
as a special case , binary weights may be used ( 1 denoting presence and 0 absence of the term in the document ) ; whether binary or nonbinary weights are used depends on the classifier learning algorithm used .
in the case of nonbinary indexing , for determining the weight wk ; of term tk in document d ; any ir-style indexing technique that represents a document as a vector of weighted terms may be used .
most of the times , the standard tfidf function is used ( see salton and buckley [ 1988 ] ) .
in order for the weights to fall in the [ 0,1 ] interval and for the documents to be represented by vectors of equal length , the weights resulting from tfidf are often normalized by cosine normalization , given by .
although normalized tfidf is the most popular one , other indexing functions have also been used , including probabilistic techniques [ g overt et al. 1999 ] or techniques for indexing structured documents [ larkey and croft 1996 ] .
functions different from tfidf are especially needed when tr is not available in its entirety from the start and # tr ( tk ) cannot thus be computed , as in adaptive filtering ; in this case , approximations of tfidf are usually employed [ dagan et al. 1997 , section 4.3 ] .
before indexing , the removal offunction words ( i.e. , topic-neutral words such as articles , prepositions , conjunctions , etc . ) is almost always performed ( exceptions include lewis et al. [ 1996 ] , nigam et al. [ 2000 ] , and riloff [ 1995 ] ) .6 concerning stemming ( i.e. , grouping words that share the same morphological root ) , its suitability to tc is controversial .
although , similarly to unsupervised term clustering ( see section 5.5.1 ) of which it is an instance , stemming has sometimes been reported to hurt effectiveness ( e.g. , baker and mccallum [ 1998 ] ) , the recent tendency is to adopt it , as it reduces both the dimensionality of the term space ( see section 5.3 ) and the stochastic dependence between terms ( see section 6.2 ) .
depending on the application , either the full text of the document or selected parts of it are indexed .
while the former option is the rule , exceptions exist .
for instance , in a patent categorization application larkey [ 1999 ] indexed only the title , the abstract , the first 20 lines of the summary , and the section containing 6 one application of tc in which it would be inappropriate to remove function words is author identification for documents of disputed paternity .
in fact , as noted in manning and sch utze [ 1999 ] , page 589 , it is often the little words that give an author away ( for example , the relative frequencies of words like because or though ) . the claims of novelty of the described invention .
this approach was made possible by the fact that documents describing patents are structured .
similarly , when a document title is available , one can pay extra importance to the words it contains [ apt e et al. 1994 ; cohen and singer 1999 ; weiss et al. 1999 ] .
when documents are flat , identifying the most relevant part of a document is instead a nonobvious task . 5.2 .
the darmstadt indexing approach the air / x system [ fuhr et al. 1991 ] occupies a special place in the literature on indexing for tc .
this system is the final result of the air project , one of the most important efforts in the history of tc : spanning a duration of more than 10 years [ knorz 1982 ; tzeras and hartmann 1993 ] , it has produced a system operatively employed since 1985 in the classification of corpora of scientific literature of o ( 105 ) documents and o ( 104 ) categories , and has had important theoretical spin-offs in the field of probabilistic indexing [ fuhr 1989 ; fuhr and buckely 1991 ] .7 the approach to indexing taken in air / x is known as the darmstadt indexing approach ( dia ) [ fuhr 1985 ] .
here , indexing is used in the sense of section 3.1 , that is , as using terms from a controlled vocabulary , and is thus a synonym of tc ( the dia was later extended to indexing with free terms [ fuhr and buckley 1991 ] ) .
the idea that underlies the dia is the use of a much wider set of features than described in section 5.1 .
all other approaches mentioned in this paper view terms as the dimensions of the learning space , where terms may be single words , stems , phrases , or ( see sections 5.5.1 and 5.5.2 ) combinations of any of these .
in contrast , the dia considers properties ( of terms , documents , 7 the air / x system , its applications ( including the air / phys system [ biebricher et al. 1988 ] , an application of air / x to indexing physics literature ) , and its experiments have also been richly documented in a series of papers and doctoral theses written in german .
the interested reader may consult fuhr et al. [ 1991 ] for a detailed bibliography .
for each possible document-category pair , the values of these features are collected in a -so-called relevance description vector rd ( d ; , ci ) .
the size of this vector is determined by the number of properties considered , and is thus independent of specific terms , categories , or documents ( for multivalued features , appropriate aggregation functions are applied in order tq yield a single value to be included in rd ( d ; , ci ) ) ; in this way an abstraction from specific terms , categories , or documents is achieved .
the main advantage of this approach is the possibility to consider additional features that can hardly be accounted for in the usual term-based approaches , for example , the location of a term within a document , or the certainty with which a phrase was identified in a document .
the term-category relationship is described by estimates , derived from the training set , of the probability p ( ci i tk ) that a document belongs to category ci , given that it contains term tk ( the dia association factor ) .8 relevance description vectors rd ( d ; , ci ) are then the final representations that are used for the classification of document d ; under category ci .
the essential ideas of the dia transforming the classification space by means of abstraction and using a more detailed text representation than the standard bag-of-words approach have not been taken up by other researchers so far .
for new tc applications dealing with structured documents or categorization of web pages , these ideas may become of increasing importance .
dimensionality reduction .
unlike in text retrieval , in tc the high dimensionality of the term space ( i.e. , the large value of iti ) may be problematic .
in fact , while typical algorithms used in text retrieval ( such as cosine matching ) can scale to high values of iti , the same does not hold of many sophisticated learning algorithms used for classifier induction ( e.g. , the llsf algorithm of yang and chute [ 1994 ] ) .
because of this , before classifier induction one often applies a pass of dimensionality reduction ( dr ) , whose effect is to reduce the size of the vector space from iti to it 'i < < iti ; the set t ' is called the reduced term set .
dr is also beneficial since it tends to reduce overfitting , that is , the phenomenon by which a classifier is tuned also to the contingent characteristics of the training data rather than just the constitutive characteristics of the categories .
classifiers that overfit the training data are good at reclassifying the data they have been trained on , but much worse at classifying previously unseen data .
experiments have shown that , in order to avoid overfitting a number of training examples roughly proportional to the number of terms used is needed ; fuhr and buckley [ 1991 , page 235 ] have suggested that 50 100 training examples per term may be needed in tc tasks .
this means that , if dr is performed , overfitting may be avoided even if a smaller amount of training examples is used .
however , in removing terms the risk is to remove potentially useful information on the meaning of the documents .
it is then clear that , in order to obtain optimal ( cost- ) effectiveness , the reduction process must be performed with care .
various dr methods have been proposed , either from the information theory or from the linear algebra literature , and their relative merits have been tested by experimentally evaluating the variation in effectiveness that a given classifier undergoes after application of the function to the term space .
there are two distinct ways of viewing dr , depending on whether the task is performed locally ( i.e. , for each individual category ) or globally : local dr : for each category ci , a set t ' of terms , with it 'i < < iti , is chosen for classification under ci ( see apt e et al. [ 1994 ] ; lewis and ringuette [ 1994 ] ; li and jain [ 1998 ] ; ng et al. [ 1997 ] ; sable and hatzivassiloglou [ 2000 ] ; sch utze et al. [ 1995 ] , wiener et al. [ 1995 ] ) .
this means that different subsets of d ~ j are used when working with the different categories .
typical values are 10 < it 'i < 50. global dr : a set t ' of terms , with it 'i < < iti , is chosen for the classification under all categories c = { c1 , ... , cic 1 ( see caropreso et al. [ 2001 ] ; mladeni c [ 1998 ] ; yang [ 1999 ] ; yang and pedersen [ 1997 ] ) .
this distinction usually does not impact on the choice of dr technique , since most such techniques can be used ( and have been used ) for local and global dr alike ( supervised dr techniques see section 5.5.1 are exceptions to this rule ) .
in the rest of this section , we will assume that the global approach is used , although everything we will say also applies to the local approach .
unlike in the previous distinction , these two ways of doing dr are tackled by very different techniques ; we will address them separately in the next two sections .
dimensionality reduction by term selection .
given a predetermined integer r , techniques for term selection ( also called term space reduction tsr ) attempt to select , from the original set t , the set t ' of terms ( with it 'i < < iti ) that , when used for document indexing , yields the highest effectiveness .
yang and pedersen [ 1997 ] have shown that tsr may even result in a moderate ( < 5 % ) increase in effectiveness , depending on the classifier , on the aggressivity itiiof the reduction , and on the tsr technique used .
moulinier et al. [ 1996 ] have used a so-called wrapper approach , that is , one in which t ' is identified by means of the same learning method that will be used for building the classifier [ john et al. 1994 ] .
starting from an initial term set , a new term set is generated by either adding or removing a term .
when a new term set is generated , a classifier based on it is built and then tested on a validation set .
the term set that results in the best effectiveness is chosen .
this approach has the advantage of being tuned to the learning algorithm being used ; moreover , if local dr is performed , different numbers of terms for different categories may be chosen , depending on whether a category is or is not easily separable from the others .
however , the sheer size of the space of different term sets makes its cost-prohibitive for standard tc applications .
a computationally easier alternative is the filtering approach [ john et al. 1994 ] , that is , keeping the it 'i < < iti terms that receive the highest score according to a function that measures the importance of the term for the tc task .
we will explore this solution in the rest of this section . 5.4.1 .
document frequency .
a simple and effective global tsr function is the document frequency # tr ( tk ) of a term tk , that is , only the terms that occur in the highest number of documents are retained .
in a series of experiments yang and pedersen [ 1997 ] have shown that with # tr ( tk ) it is possible to reduce the dimensionality by a factor of 10 with no loss in effectiveness ( a reduction by a factor of 100 bringing about just a small loss ) .
this seems to indicate that the terms occurring most frequently in the collection are the most valuable for tc .
as such , this would seem to contradict a well-known law of ir , according to which the terms with low-to-medium document frequency are the most informative ones [ salton and buckley 1988 ] .
but these two results do not contradict each other , since it is well known ( see salton et al. [ 1975 ] ) that the large majority of the words occurring in a corpus have a very low document frequency ; this means that by reducing the term set by a factor of 10 using document frequency , only such words are removed , while the words from low-to-medium to high document frequency are preserved .
of course , stop words need to be removed in advance , lest only topic-neutral words are retained [ mladeni c 1998 ] .
finally , note that a slightly more empirical form of tsr by document frequency is adopted by many authors , who remove all terms occurring in at most x training documents ( popular values for x range from 1 to 3 ) , either as the only form of dr [ maron 1961 ; ittner et al. 1995 ] or before applying another more sophisticated form [ dumais et al. 1998 ; li and jain 1998 ] .
a variant of this policy is removing all terms that occur at most x times in the training set ( e.g. , dagan et al. [ 1997 ] ; joachims [ 1997 ] ) , with popular values for x ranging from 1 ( e.g. , baker and mccallum [ 1998 ] ) to 5 ( e.g. , apt e et al. [ 1994 ] ; cohen [ 1995a ] ) .
other information-theoretic term selection functions .
other more sophisticated information-theoretic functions have been used in the literature , among them the dia association factor [ fuhr et al. 1991 ] , chi-square [ caropreso et al. 2001 ; galavotti et al. 2000 ; sch utze et al. 1995 ; sebastiani et al. 2000 ; yang and pedersen 1997 ; yang and liu 1999 ] , ngl coefficient [ ng et al. 1997 ; ruiz and srinivasan 1999 ] , information gain [ caropreso et al. 2001 ; larkey 1998 ; lewis 1992a ; lewis and ringuette 1994 ; mladeni c 1998 ; moulinier and ganascia 1996 ; yang and pedersen 1997 , yang and liu 1999 ] , mutual information [ dumais et al. 1998 ; lam et al. 1997 ; larkey and croft 1996 ; lewis and ringuette 1994 ; li and jain 1998 ; moulinier et al. 1996 ; ruiz and srinivasan 1999 ; taira and haruno 1999 ; yang and pedersen 1997 ] , odds ratio [ caropreso et al. 2001 ; mladeni c 1998 ; ruiz and srinivasan 1999 ] , relevancy score [ wiener et al. 1995 ] , and gss coefficient [ galavotti et al. 2000 ] .
the mathematical definitions of these measures are summarized for convenience in table i.9 here , probabilities are interpreted on an event space of documents ( e.g. , p ( tk , ci ) denotes the probability that , for a random document x , term tk does not occur in x and x belongs to category ci ) , and are estimated by counting occurrences in the training set .
all functions are specified locally to a specific category ci ; in order to assess the value of a term tk in a global , category- independent sense , either the sum fsum ( tk ) = e | c | = 1 f ( tk , ci ) , or the weighted sum fwsum ( tk ) = ei = 1 p ( ci ) f ( tk , ci ) , or the maximum fmax ( tk ) = maxi ~ ~ 1 f ( tk , ci ) of their category-specific values f ( tk , ci ) are usually computed .
these functions try to capture the intuition that the best terms for ci are the ones distributed most differently in the sets of positive and negative examples of ci .
however , interpretations of this principle vary across different functions .
for instance , in the experimental sciences x2 is used to measure how the results of an observation differ ( i.e. , are independent ) from the results expected according to an initial hypothesis ( lower values indicate lower dependence ) .
in dr we measure how independent tk and ci are .
the terms tk 9 for better uniformity table i views all the tsr functions of this section in terms of subjective probability .
in some cases such as x2 ( tk , ci ) this is slightly artificial , since this function is not usually viewed in probabilistic terms .
the formulae refer to the local ( i.e. , category-specific ) forms of the functions , which again is slightly artificial in some cases .
note that the ngl and gss coefficients are here named after their authors , since they had originally been given names that might generate some confusion if used here .
while each tsr function has its own rationale , the ultimate word on its value is the effectiveness it brings about .
various experimental comparisons of tsr functions have thus been carried out [ caropreso et al. 2001 ; galavotti et al. 2000 ; mladeni c 1998 ; yang and pedersen 1997 ] .
in these experiments most functions listed in table i ( with the possible exception of mi ) have improved on the results of document frequency .
for instance , yang and pedersen [ 1997 ] have shown that , with various classifiers and various initial corpora , sophisticated techniques such as igs " m ( tk , ci ) or x2 max ( tk , ci ) can reduce the dimensionality of the term space by a factor of 100 with no loss ( or even with a small increase ) of effectiveness .
collectively , the experiments reported in the above-mentioned papers seem to indicate that { ors " m , ngls " m , gssmax } > { x2max , igs " m } > { x2wavg } > j { mimax , miws " m } , where > means performs better than .
however , it should be noted that these results are just indicative , and that more general statements on the relative merits of these functions could be made only as a result of comparative experiments performed in thoroughly controlled conditions and on a variety of different situations ( e.g. , different classifiers , different initial corpora , ... ) .
dimensionality reduction by term extraction .
given a predetermined it 'i < < iti , term extraction attempts to generate , from the original set t , a set t ~ of synthetic terms that maximize effectiveness .
the rationale for using synthetic ( rather than naturally occurring ) terms is that , due to the pervasive problems of polysemy , homonymy , and synonymy , the original terms may not be optimal dimensions for document content representation .
methods for term extraction try to solve these problems by creating artificial terms that do not suffer from them .
any term extraction method consists in ( i ) a method for extracting the new terms from the old ones , and ( ii ) a method for converting the original document representations into new representations based on the newly synthesized dimensions .
two term extraction methods have been experimented with in tc , namely term clustering and latent semantic indexing .
term clustering .
term clustering tries to group words with a high degree of pairwise semantic relatedness , so that the groups ( or their centroids , or a representative of them ) may be used instead of the terms as dimensions of the vector space .
term clustering is different from term selection , since the former tends to address terms synonymous ( or near-synonymous ) with other terms , while the latter targets noninformative terms.10 lewis [ 1992a ] was the first to investigate the use of term clustering in tc .
the method he employed , called reciprocal nearest neighbor clustering , consists in creating clusters of two terms that are one the most similar to the other according to some measure of similarity .
his results were inferior to those obtained by single-word indexing , possibly due to a disappointing performance by the clustering method : as lewis [ 1992a , page 48 ] said , the relationships captured in the clusters are mostly accidental , rather than the systematic relationships that were hoped for .
li and jain [ 1998 ] viewed semantic relatedness between words in terms of their co-occurrence and co-absence within training documents .
by using this technique in the context of a hierarchical clustering algorithm , they witnessed only a marginal effectiveness improvement ; however , the small size of their experiment ( see section 6.11 ) hardly allows any definitive conclusion to be reached .
both lewis [ 1992a ] and li and jain [ 1998 ] are examples of unsupervised clustering , since clustering is not affected by the category labels attached to the documents .
baker and mccallum [ 1998 ] provided instead an example of supervised clustering , as the distributional clustering method they employed clusters together those terms that tend to indicate the presence of the same category , or group of categories .
their experiments , carried out in the context of a naive bayes classifier ( see section 6.2 ) , showed only a 2 % effectiveness loss with an aggressivity of 1,000 , and even showed some effectiveness improvement with less aggressive levels of reduction .
later experiments by slonim and tishby [ 2001 ] have confirmed the potential of supervised clustering methods for term extraction .
latent semantic indexing .
latent semantic indexing ( lsi [ deerwester et al. 1990 ] ) is a dr technique developed in ir in order to address the problems deriving from the use of synonymous , near-synonymous , and polysemous words as dimensions of document representations .
this technique compresses document vectors into vectors of a lower-dimensional space whose dimensions are obtained as combinations of the original dimensions by looking at their patterns of co- occurrence .
in practice , lsi infers the dependence among the original terms from a corpus and wires this dependence into the newly obtained , independent dimensions .
the function mapping original vectors into new vectors is obtained by applying a singular value decomposition to the matrix formed by the original document vectors .
in tc this technique is applied by deriving the mapping function from the training set and then applying it to training and test documents alike .
one characteristic of lsi is that the newly obtained dimensions are not , unlike in term selection and term clustering , intuitively interpretable .
however , they work well in bringing out the latent semantic structure of the vocabulary used in the corpus .
for instance , sch utze et al. [ 1995 , page 235 ] discussed the classification under category demographic shifts in the u.s. with economic impact of a document that was indeed a positive test instance for the category , and that contained , among others , the quite revealing sentence the nation grew to 249.6 million people in the 1980s as more americans left the industrial and agricultural heartlands for the south and west .
the classifier decision was incorrect when local dr had been performed by x2-based term selection retaining the top original 200 terms , but was correct when the same task was tackled by means of lsi .
this well exemplifies how lsi works : the above sentence does not contain any of the 200 terms most relevant to the category selected by x2 , but quite possibly the words contained in it have concurred to produce one or more of the lsi higher-order terms that generate the document space of the category .
as sch utze et al. [ 1995 , page 230 ] put it , if there is a great number of terms which all contribute a small amount of critical information , then the combination of evidence is a major problem for a term-based classifier .
a drawback of lsi , though , is that if some original term is particularly good in itself at discriminating a category , that discrimination power may be lost in the new vector space .
wiener et al. [ 1995 ] used lsi in two alternative ways : ( i ) for local dr , thus creating several category-specific lsi representations , and ( ii ) for global dr , thus creating a single lsi representation for the entire category set .
their experiments showed the former approach to perform better than the latter , and both approaches to perform better than simple tsr based on relevancy score ( see table i ) .
sch utze et al. [ 1995 ] experimentally compared lsi-based term extraction with x2-based tsr using three different classifier learning techniques ( namely , linear discriminant analysis , logistic regression , and neural networks ) .
their experiments showed lsi to be far more effective than x2 for the first two techniques , while both methods performed equally well for the neural network classifier .
for other tc works that have used lsi or similar term extraction techniques , see hull [ 1994 ] , li and jain [ 1998 ] , schutze [ 1998 ] , weigend et al. [ 1999 ] , and yang [ 1995 ] .
inductive construction of text classifiers .
the inductive construction of text classifiers has been tackled in a variety of ways .
here we will deal only with the methods that have been most popular in tc , but we will also briefly mention the existence of alternative , less standard approaches .
we start by discussing the general form that a text classifier has .
let us recall from section 2.4 that there are two alternative ways of viewing classification : hard ( fully automated ) classification and ranking ( semiautomated ) classification .
the inductive construction of a ranking classifier for category ci e c usually consists in the definition of a function csvi : d -- > [ 0 , 1 ] that , given a document dj , returns a categorization status value for it , that is , a number between 0 and 1 which , roughly speaking , represents the evidence for the fact that dj e ci .
documents are then ranked according to their csvi value .
this works for document-ranking tc ; category-ranking tc is usually tackled by ranking , for a given document dj , its csvi scores for the different categories in c = { c1 , ... , c | c | l .
the csvi function takes up different meanings according to the learning method used : for instance , in the naive bayes approach of section 6.2 csvi ( dj ) is defined in terms of a probability , whereas in the rocchio approach discussed in section 6.7 csvi ( dj ) is a measure of vector closeness in | t | -dimensional space .
the construction of a hard classifier may follow two alternative paths .
the former consists in the definition of a function csvi : d -- > { t , fl .
the latter consists instead in the definition of a function csvi : d -- > [ 0 , 1 ] , analogous to the one used for ranking classification , followed by the definition of a threshold ti such that csvi ( dj ) > ti is interpreted as t while csvi ( d ; ) < ri is interpreted as f.11 the definition of thresholds will be the topic of section 6.1 .
in sections 6.2 to 6.12 we will instead concentrate on the definition of csvi , discussing a number of approaches that have been applied in the tc literature .
in general we will assume we are dealing with hard classification ; it will be evident from the context how and whether the approaches can be adapted to ranking classification .
the presentation of the algorithms will be mostly qualitative rather than quantitative , that is , will focus on the methods for classifier learning rather than on the effectiveness and efficiency of the classifiers built by means of them ; this will instead be the focus of section 7 .
determining thresholds .
there are various policies for determining the threshold ri , also depending on the constraints imposed by the application .
the most important distinction is whether the threshold is derived analytically or experimentally .
the former method is possible only in the presence of a theoretical result that indicates how to compute the threshold that maximizes the expected value of the effectiveness function [ lewis 1995a ] .
this is typical of classifiers that output probability estimates of the membership of d ; in ci ( see section 6.2 ) and whose effectiveness is computed by decision-theoretic measures such as utility ( see section 7.1.3 ) ; we thus defer the discussion of this policy ( which is called probability thresholding in lewis [ 1995a ] ) to section 7.1.3 .
when such a theoretical result is not known , one has to revert to the latter method , which consists in testing different values for ri on a validation set and choosing the value which maximizes effectiveness .
a second , popular experimental policy is proportional thresholding [ iwayama and tokunaga 1995 ; larkey 1998 ; lewis 1992a ; lewis and ringuette 1994 ; wiener et al. 1995 ] , also called pcut in yang [ 1999 ] .
this policy consists in choosing the value of ri for which gva ( ci ) is closest to gtr ( ci ) , and embodies the principle that the same percentage of documents of both training and test set should be classified under ci .
for obvious reasons , this policy does not lend itself to document- pivoted tc .
sometimes , depending on the application , a fixed thresholding policy ( a.k.a. k-per-doc thresholding [ lewis 1992a ] or rcut [ yang 1999 ] ) is applied , whereby it is stipulated that a fixed number k of categories , equal for all d ; s , are to be assigned to each document d ; .
this is often used , for instance , in applications of tc to automated document indexing [ field 1975 ; lam et al. 1999 ] .
quite clearly , this policy is mostly at home with document-pivoted tc .
however , it suffers from a certain coarseness , as the fact that k is equal for all documents ( nor could this be otherwise ) allows no fine-tuning .
in his experiments lewis [ 1992a ] found the proportional policy to be superior to probability thresholding when microaveraged effectiveness was tested but slightly inferior with macroaveraging ( see section 7.1.1 ) .
yang [ 1999 ] found instead csv thresholding to be superior to proportional thresholding ( possibly due to her category- specific optimization on a validation set ) , and found fixed thresholding to be consistently inferior to the other two policies .
the fact that these latter results have been obtained across different classifiers no doubt reinforces them .
in general , aside from the considerations above , the choice of the thresholding policy may also be influenced by the application ; for instance , in applying a text classifier to document indexing for boolean systems a fixed thresholding policy might be chosen , while a proportional or csv thresholding method might be chosen for web page classification under hierarchical catalogues .
probabilistic classifiers .
probabilistic classifiers that use this assumption are called na ve bayes classifiers , and account for most of the probabilistic approaches to tc in the literature ( see joachims [ 1998 ] ; koller and sahami [ 1997 ] ; larkey and croft [ 1996 ] ; lewis [ 1992a ] ; lewis and gale [ 1994 ] ; li and jain [ 1998 ] ; robertson and harding [ 1984 ] ) .
the naive character of the classifier is due to the fact that usually this assumption is , quite obviously , not verified in practice .
one of the best-known naive bayes approaches is the binary independence classifier [ robertson and sparck jones 1976 ] , which results from using binary-valued vector representations for documents .
note also that log 1pp ( ci ) and ~ k111log 1-pki are constant for all documents , and may thus be disregarded . 13 defining a classifier for category ci thus basically requires estimating the 2i7i parameters { p1i , p1 i , , pi7ii , pi7i i } from the training data , which may be done in the obvious way .
note that in general the classification of a given document does not require one to compute a sum of i7i factors as the presence of e7i1 wkj log pk pki ) o would imply ; in fact , all the factors for which wkj = 0 may be disregarded , and this accounts for the vast majority of them , since document vectors are usually very sparse .
the method we have illustrated is just one of the many variants of the naive bayes approach , the common denominator of which is ( 4 ) .
a recent paper by lewis [ 1998 ] is an excellent roadmap on the various directions that research on naive bayes classifiers has taken ; among these are the ones aiming to relax the constraint that document vectors should be binary-valued .
this looks natural , given that weighted indexing techniques ( see fuhr [ 1989 ] ; salton and buckley [ 1988 ] ) accounting for the importance of tk for dj play a key role in ir. to introduce document length normalization .
the value of log 1 p ( ciid ) ) tends to be more extreme ( i.e. , very high or very low ) for long documents ( i.e. , documents such that wkj = 1 for many values of k ) , irrespectively of their semantic relatedness to ci , thus calling for length normalization .
taking length into account is easy in non- probabilistic approaches to classification ( see section 6.7 ) , but is problematic in probabilistic ones ( see lewis [ 1998 ] , section 5 ) .
one possible answer is to switch from an interpretation of naive bayes in which documents are events to one in which terms are events [ baker and mccallum 1998 ; mccallum et al. 1998 ; chakrabarti et al. 1998a ; guthrie et al. 1994 ] .
this accounts for document length naturally but , as noted by lewis [ 1998 ] , has the drawback that different occurrences of the same word within the same document are viewed as independent , an assumption even more implausible than ( 4 ) . to relax the independence assumption .
this may be the hardest route to follow , since this produces classifiers of higher computational cost and characterized by harder parameter estimation problems [ koller and sahami 1997 ] .
earlier efforts in this direction within probabilistic text search ( e.g. , vanrijsbergen [ 1977 ] ) have not shown the performance improvements that were hoped for .
recently , the fact that the binary independence assumption seldom harms effectiveness has also been given some theoretical justification [ domingos and pazzani 1997 ] .
the quotation of text search in the last paragraph is not casual .
unlike other types of classifiers , the literature on probabilistic classifiers is inextricably intertwined with that on probabilistic search systems ( see crestani et al. [ 1998 ] for a review ) , since these latter attempt to determine the probability that a document falls in the category denoted by the query , and since they are the only search systems that take relevance feedback , a notion essentially involving supervised learning , as central .
decision tree classifiers .
probabilistic methods are quantitative ( i.e. , numeric ) in nature , and as such have sometimes been criticized since , effective as they may be , they are not easily interpretable by humans .
a class of algorithms that do not suffer from this problem are symbolic ( i.e. , nonnumeric ) algorithms , among which inductive rule learners ( which we will discuss in section 6.4 ) and decision tree learners are the most important examples .
a decision tree ( dt ) text classifier ( see mitchell [ 1996 ] , chapter 3 ) is a tree in which internal nodes are labeled by terms , branches departing from them are labeled by tests on the weight that the term has in the test document , and leafs are labeled by categories .
such a classifier categorizes a test document d ; by recursively testing for the weights that the terms labeling the internal nodes have in vector d ~ ; , until a leaf node is reached ; the label of this node is then assigned to d ; .
most such classifiers use binary document representations , and thus consist of binary trees .
an example dt is illustrated in figure 2 .
there are a number of standard packages for dt learning , and most dt approaches to tc have made use of one such package .
among the most popular ones are id3 ( used by fuhr et al. [ 1991 ] ) , c4.5 ( used by cohen and hirsh [ 1998 ] , cohen and singer [ 1999 ] , joachims [ 1998 ] , and lewis and catlett [ 1994 ] ) , and c5 ( used by li and jain [ 1998 ] ) .
tc efforts based on experimental dt packages include dumais et al. [ 1998 ] , lewis and ringuette [ 1994 ] , and weiss et al. [ 1999 ] .
a possible method for learning a dt for category ci consists in a divide and conquer strategy of ( i ) checking whether all the training examples have the same label ( either ci or ci ) ; ( ii ) if not , selecting a term tk , partitioning tr into classes of documents that have the same value for tk , and placing each such class in a separate subtree .
the process is recursively repeated on the subtrees until each leaf of the tree so generated contains training examples assigned to the same category ci , which is then chosen as the label for the leaf .
the key step is the choice of the term tk on which to operate the partition , a choice which is generally made according to an information gain or entropy criterion .
however , such a fully grown tree may be prone to overfitting , as some branches may be too specific to the training data .
most dt learning methods thus include a method for growing the tree and one for pruning it , that is , for removing the overly specific branches .
variations on this basic schema for dt learning abound [ mitchell 1996 , section 3 ] .
dt text classifiers have been used either as the main classification tool [ fuhr et al. 1991 ; lewis and catlett 1994 ; lewis and ringuette 1994 ] , or as baseline classifiers [ cohen and singer 1999 ; joachims 1998 ] , or as members of classifier committees [ li and jain 1998 ; schapire and singer 2000 ; weiss et al. 1999 ] .
decision rule classifiers .
a classifier for category ci built by an inductive rule learning method consists of a dnf rule , that is , of a conditional rule with a premise in disjunctive normal form ( dnf ) , of the type illustrated in figure 1.14 the literals ( i.e. , possibly negated keywords ) in the premise denote the presence ( nonnegated keyword ) or absence ( negated keyword ) of the keyword in the test document d ; , while the clause head denotes the decision to classify d ; under ci .
dnf rules are similar to dts in that they can encode any boolean function .
however , an advantage of dnf rule learners is that they tend to generate more compact classifiers than dt learners .
rule learning methods usually attempt to select from all the possible covering rules ( i.e. , rules that correctly classify all the training examples ) the best one according to some minimality criterion .
while dts are typically built by a top- down , divide-and-conquer strategy , dnf rules are often built in a bottom-up fashion .
initially , every training example d ; is viewed as a clause 771 , , 77n -- > yi , where 771 , , 77n are the terms contained in d ; and yi equals ci or ci according to whether d ; is a positive or negative example of ci .
this set of clauses is already a dnf classifier for ci , but obviously scores high in terms of overfitting .
the learner applies then a process of generalization in which the rule is simplified through a series of modifications ( e.g. , removing premises from clauses , or merging clauses ) that maximize its compactness while at the same time not affecting the covering property of the classifier .
at the end of this process , a pruning phase similar in spirit to that employed in dts is applied , where the ability to correctly classify all the training examples is traded for more generality .
dnf rule learners vary widely in terms of the methods , heuristics and criteria employed for generalization and pruning .
among the dnf rule learners that have been applied to tc are charade [ moulinier and ganascia 1996 ] , dl-esc [ li and yamanishi 1999 ] , ripper [ cohen 1995a ; cohen and hirsh 1998 ; cohen and singer 1999 ] , scar [ moulinier et al. 1996 ] , and swap-1 [ apt e 1994 ] .
while the methods above use rules of propositional logic ( pl ) , research has also been carried out using rules of first- order logic ( fol ) , obtainable through the use of inductive logic programming methods .
cohen [ 1995a ] has extensively compared pl and fol learning in tc ( for instance , comparing the pl learner ripper with its fol version flipper ) , and has found that the additional representational power of fol brings about only modest benefits .
regression methods .
various tc efforts have used regression models ( see fuhr and pfeifer [ 1994 ] ; ittner et al. [ 1995 ] ; lewis and gale [ 1994 ] ; sch utze et al. [ 1995 ] ) .
regression denotes the approximation of a real-valued ( instead than binary , as in the case of classification ) function ~ ^ by means of a function 4 ) that fits the training data [ mitchell 1996 , page 236 ] .
here we will describe one such model , the linear least-squares fit ( llsf ) applied to tc by yang and chute [ 1994 ] .
in llsf , each document d j has two vectors associated to it : an input vector i ( d j ) of iti weighted terms , and an output vector o ( dj ) of ici weights representing the categories ( the weights for this latter vector are binary for training documents , and are nonbinary csv 's for test documents ) .
classification may thus be seen as the task of determining an output vector o ( d j ) for test document d j , given its input vector i ( d j ) ; hence , building a classifier boils down to computing a ici x iti matrix m such that mi ( d j ) = o ( d j ) .
llsf computes the matrix from the training data by computing a linear least- squares fit that minimizes the error on the training set according to the formula m = arg minm ii mi ^ o iif , where arg minm ( x ) stands as usual for the m for which x is minimum , ii v iif def / eicl1 eis i1 vij resents the so-called frobenius norm of a ici x iti matrix , i is the iti x idri matrix whose columns are the input vectors of the training documents , and o is the ici x idri matrix whose columns are the output vectors of the training documents .
the m matrix is usually computed by performing a singular value decomposition on the training set , and its generic entry mik represents the degree of association between category ci and term tk .
the experiments of yang and chute [ 1994 ] and yang and liu [ 1999 ] indicate that llsf is one of the most effective text classifiers known to date .
one of its disadvantages , though , is that the cost of computing the m matrix is much higher than that of many other competitors in the tc arena .
online methods .
methods for learning linear classifiers are often partitioned in two broad classes , batch methods and on-line methods .
batch methods build a classifier by analyzing the training set all at once .
within the tc literature , one example of a batch method is linear discriminant analysis , a model of the stochastic dependence between terms that relies on the covariance matrices of the categories [ hull 1994 ; sch utze et al. 1995 ] .
however , the foremost example of a batch method is the rocchio method ; because of its importance in the tc literature , this will be discussed separately in section 6.7 .
in this section we will instead concentrate on on-line methods .
on-line ( a.k.a. incremental ) methods build a classifier soon after examining the first training document , and incrementally refine it as they examine new ones .
this may be an advantage in the applications in which dr is not available in its entirety from the start , or in which the meaning of the category may change in time , as for example , in adaptive filtering .
this is also apt to applications ( e.g. , semiautomated classification , adaptive filtering ) in which we may expect the user of a classifier to provide feedback on how test documents have been classified , as in this case further training may be performed during the operating phase by exploiting user feedback .
a simple on-line method is the perceptron algorithm , first applied to tc by sch utze et al. [ 1995 ] and wiener et al. [ 1995 ] , and subsequently used by dagan et al. [ 1997 ] and ng et al. [ 1997 ] .
in this algorithm , the classifier for ci is first initialized by setting all weights wki to the same positive value .
following the misclassification of a positive instance , active terms have their w + ki weight promoted and their w ^ ki weight demoted , whereas in the case of a negative instance it is w + ki that gets denoted while w ^ ki gets promoted ( for the rest , promotions and demotions are as in positive winnow ) .
balanced winnow allows negative wki weights , while in the perceptron and in positive winnow the wki weights are always positive .
in experiments conducted by dagan et al. [ 1997 ] , positive winnow showed a better effectiveness than perceptron but was in turn outperformed by ( dagan et al. s own version of ) balanced winnow .
other on-line methods for building text classifiers are widrow-hoff , a refinement of it called exponentiated gradient ( both applied for the first time to tc in [ lewis et al. 1996 ] ) and sleeping experts [ cohen and singer 1999 ] , a version of balanced winnow .
while the first is an additive weight-updating algorithm , the second and third are multiplicative .
key differences with the previously described algorithms are that these three algorithms ( i ) update the classifier not only after misclassifying a training example , but also after classifying it correctly , and ( ii ) update the weights corresponding to all terms ( instead of just active ones ) .
the rocchio method if the result of the classification is correct , nothing is done , while if it is wrong , the weights of the classifier are modified : if dj was a positive example of ci , then the weights wki of active terms ( i.e. , the terms tk such that wkj = 1 ) are promoted by increasing them by a fixed quantity a > 0 ( called learning rate ) , while if dj was a negative example of ci then the same weights are demoted by decreasing them by a .
note that when the classifier has reached a reasonable level of effectiveness , the fact that a weight wki is very low means that tk has negatively contributed to the classification process so far , and may thus be discarded from the representation .
we may then see the perceptron algorithm ( as all other incremental learning methods ) as allowing for a sort of on-the-fly term space reduction [ dagan et al. 1997 , section 4.4 ] .
the perceptron classifier has shown a good effectiveness in all the experiments quoted above .
the perceptron is an additive weight-updating algorithm .
a multiplicative variant of it is positive winnow [ dagan et al. 1997 ] , which differs from perceptron because two different constants a1 > 1 and 0 < a2 < 1 are used for promoting and demoting weights , respectively , and because promotion and demotion are achieved by multiplying , instead of adding , by a1 and a2 .
balanced winnow [ dagan et al. 1997 ] is a further variant of positive winnow , in which the classifier consists of two weights some linear classifiers consist of an explicit profile ( or prototypical document ) of the category .
this has obvious advantages in terms of interpretability , as such a profile is more readily understandable by a human than , say , a neural network ments , while for the latter the vector d ~ j representing the test document is used as a query against the set of classifiers .
the rocchio method is used for inducing linear , profile-style classifiers .
it relies on an adaptation to tc of the well- known rocchio s formula for relevance feedback in the vector-space model , and it is perhaps the only tc method rooted in the ir tradition rather than in the ml one .
this adaptation was first proposed by hull [ 1994 ] , and has been used by many authors since then , either as an object of research in its own right [ ittner et al. 1995 ; joachims 1997 ; sable and hatzivassiloglou 2000 ; schapire et al. 1998 ; singhal et al. 1997 ] , or as a baseline classifier [ cohen and singer 1999 ; galavotti et al. 2000 ; joachims 1998 ; lewis et al. 1996 ; schapire and singer 2000 ; sch utze et al. 1995 ] , or as a member of a classifier committee [ larkey and croft 1996 ] ( see section 6.11 ) .
in this formula , 0 and y are control parameters that allow setting the relative importance of positive and negative examples .
for instance , if 0 is set to 1 and y to 0 ( as in dumais et al. [ 1998 ] ; hull [ 1994 ] ; joachims [ 1998 ] ; sch utze et al. [ 1995 ] ) , the profile of ci is the centroid of its positive training examples .
a classifier built by means of the rocchio method rewards the closeness of a test document to the centroid of the positive training examples , and its distance from the centroid of the negative training examples .
the role of negative examples is usually deemphasized , by setting 0 to a high value and y to a low one ( e.g. , cohen and singer [ 1999 ] , ittner et al. [ 1995 ] , and joachims [ 1997 ] use 0 = 16 and y = 4 ) .
this method is quite easy to implement , and is also quite efficient , since learning a classifier basically comes down to averaging weights .
in terms of effectiveness , instead , a drawback is that if the documents in the category tend to occur in disjoint clusters ( e.g. , a set of newspaper articles lebeled with the sports category and dealing with either boxing or rock- climbing ) , such a classifier may miss most of them , as the centroid of these documents may fall outside all of these clusters ( see figure 3 ( a ) ) .
more generally , a classifier built by the rocchio method , as all linear classifiers , has the disadvantage that it divides the space of documents linearly .
this situation is graphically depicted in figure 3 ( a ) , where documents are classified within ci if and only if they fall within the circle .
note that even most of the positive training examples would not be classified correctly by the classifier .
small crosses and circles denote positive and negative training instances , respectively .
the big circles denote the influence area of the classifier .
note that , for ease of illustration , document similarities are here viewed in terms of euclidean distance rather than , as is more common , in terms of dot product or cosine .
rocchio formula is used for relevance feedback in ir , near-positives tend to be used rather than generic negatives , as the documents on which user judgments are available are among the ones that had scored highest in the previous ranking .
early applications of the rocchio formula to tc ( e.g. , hull [ 1994 ] ; ittner et al. [ 1995 ] ) generally did not make a distinction between near-positives and generic negatives .
in order to select the near- positives schapire et al. [ 1998 ] issue a query , consisting of the centroid of the positive training examples , against a document base consisting of the negative training examples ; the top-ranked ones are the most similar to this centroid , and are then the near-positives .
wiener et al. [ 1995 ] instead equate the near-positives of ci to the positive examples of the sibling categories of ci , as in the application they work on ( tc with hierarchically organized category sets ) the notion of a sibling category of ci is well defined .
a similar policy is also adopted by ng et al. [ 1997 ] , ruiz and srinivasan [ 1999 ] , and weigend et al. [ 1999 ] .
by using query zoning plus other enhancements ( tsr , statistical phrases , and a method called dynamic feedback optimization ) , schapire et al. [ 1998 ] have found that a rocchio classifier can achieve an effectiveness comparable to that of a state-of-the-art ml method such as boosting ( see section 6.11.1 ) while being 60 times quicker to train .
these recent results will no doubt bring about a renewed interest for the rocchio classifier , previously considered an underperformer [ cohen and singer 1999 ; joachims 1998 ; lewis et al.1996 ; sch utze et al.1995 ; yang 1999 ] .
neural networks .
a neural network ( nn ) text classifier is a network of units , where the input units represent terms , the output unit ( s ) represent the category or categories of interest , and the weights on the edges connecting units represent dependence relations .
for classifying a test document dj , its term weights wkj are loaded into the input units ; the activation of these units is propagated forward through the network , and the value of the output unit ( s ) determines the categorization decision ( s ) .
a typical way of training nns is backpropagation , whereby the term weights of a training document are loaded into the input units , and if a misclassification occurs the error is backpropagated so as to change the parameters of the network and eliminate or minimize the error .
the simplest type of nn classifier is the perceptron [ dagan et al. 1997 ; ng et al. 1997 ] , which is a linear classifier and as such has been extensively discussed in section 6.6 .
other types of linear nn classifiers implementing a form of logistic regression have also been proposed and tested by sch utze et al. [ 1995 ] and wiener et al. [ 1995 ] , yielding very good effectiveness .
a nonlinear nn [ lam and lee 1999 ; ruiz and srinivasan 1999 ; sch utze et al. 1995 ; weigend et al. 1999 ; wiener et al. 1995 ; yang and liu 1999 ] is instead a network with one or more additional layers of units , which in tc usually represent higher-order interactions between terms that the network is able to learn .
when comparative experiments relating nonlinear nns to their linear counterparts have been performed , the former have yielded either no improvement [ sch utze et al. 1995 ] or very small improvements [ wiener et al. 1995 ] over the latter .
example-based classifiers .
example-based classifiers do not build an explicit , declarative representation of the category ci , but rely on the category labels attached to the training documents similar to the test document .
these methods have thus been called lazy learners , since they defer the decision on how to generalize beyond the training data until each new query instance is encountered [ mitchell 1996 , page 244 ] .
the first application of example-based methods ( a.k.a. memory-based reasoning methods ) to tc is due to creecy , masand and colleagues [ creecy et al. 1992 ; masand et al. 1992 ] ; other examples include joachims [ 1998 ] , lam et al. [ 1999 ] , larkey [ 1998 ] , larkey [ 1999 ] , li and jain [ 1998 ] , yang and pedersen [ 1997 ] , and yang and liu [ 1999 ] .
our presentation of the example-based approach will be based on the k-nn ( for k nearest neighbors ) algorithm used by yang [ 1994 ] .
for deciding whether d j e ci , k-nn looks at whether the k training documents most similar to d j also are in ci ; if the answer is positive for a large enough proportion of them , a positive decision is taken , and a negative decision is taken otherwise .
actually , yang s is a distance-weighted version of k-nn ( see [ mitchell 1996 , section 8.2.1 ] ) , since the fact that a most similar document is in ci is weighted by its similarity with the test document .
classifying d j by means of k-nn thus comes down to computing can then be used to convert the real- valued csvi s into binary categorization decisions .
in ( 9 ) , rsv ( d j , dz ) represents some measure or semantic relatedness between a test document d j and a training document dz ; any matching function , be it probabilistic ( as used by larkey and croft [ 1996 ] ) or vector-based ( as used by yang [ 1994 ] ) , from a ranked ir system may be used for this purpose .
the construction of a k-nn classifier also involves determining ( experimentally , on a validation set ) a threshold k that indicates how many top- ranked training documents have to be considered for computing csvi ( dj ) .
larkey and croft [ 1996 ] used k = 20 , while yang [ 1994 , 1999 ] has found 30 < k < 45 to yield the best effectiveness .
anyhow , various experiments have shown that increasing the value of k does not significantly degrade the performance .
note that k-nn , unlike linear classifiers , does not divide the document space linearly , and hence does not suffer from the problem discussed at the end of section 6.7 .
this method is naturally geared toward document-pivoted tc , since ranking the training documents for their similarity with the test document can be done once for all categories .
for category-pivoted tc , one would need to store the document ranks for each test document , which is obviously clumsy ; dpc is thus de facto the only reasonable way to use k-nn .
a number of different experiments ( see section 7.3 ) have shown k-nn to be quite effective .
however , its most important drawback is its inefficiency at classification time : while , for example , with a linear classifier only a dot product needs to be computed to classify a test document , k-nn requires the entire training set to be ranked for similarity with the test document , which is much more expensive .
this is a drawback of lazy learning methods , since they do not have a true training phase and thus defer all the computation to classification time .
other example-based techniques .
various example-based techniques have been used in the tc literature .
for example , cohen and hirsh [ 1998 ] implemented an example-based classifier by extending standard relational dbms technology with similarity-based soft joins .
the difference from the original k-nn approach is that if a training document dz similar to the test document d ; does not belong to ci , this information is not discarded but weights negatively in the decision to classify d ; under ci .
a combination of profile- and example- based methods was presented in lam and ho [ 1998 ] .
in this work a k-nn system was fed generalized instances ( gis ) in place of training documents .
this approach may be seen as the result of clustering the training set , thus obtaining a set of clusters ki = { ki1 , ... , kiki1 } ; this exploits the superior effectiveness ( see figure 3 ) of k-nn over linear classifiers while at the same time avoiding the sensitivity of k-nn to the presence of outliers ( i.e. , positive instances of ci that lie out of the region where most other positive instances of ci are located ) in the training set .
fig . 4 .
learning support vector classifiers .
the small crosses and circles represent positive and negative training examples , respectively , whereas lines represent decision surfaces .
decision surface ai ( indicated by the thicker line ) is , among those shown , the best possible one , as it is the middle element of the widest set of parallel decision surfaces ( i.e. , its minimum distance to any training example is maximum ) .
small boxes indicate the support vectors .
building classifiers by support vector machines .
the support vector machine ( svm ) method has been introduced in tc by joachims [ 1998 , 1999 ] and subsequently used by drucker et al. [ 1999 ] , dumais et al. [ 1998 ] , dumais and chen [ 2000 ] , klinkenberg and joachims [ 2000 ] , taira and haruno [ 1999 ] , and yang and liu [ 1999 ] .
in geometrical terms , it may be seen as the attempt to find , among all the surfaces a1 , a2 , ... in iti-dimensional space that separate the positive from the negative training examples ( decision surfaces ) , the ai that separates the positives from the negatives by the widest possible margin , that is , such that the separation property is invariant with respect to the widest possible traslation of ai .
this idea is best understood in the case in which the positives and the negatives are linearly separable , in which case the decision surfaces are ( iti-1 ) -hyperplanes .
in the two-dimensional case of figure 4 , various lines may be chosen as decision surfaces .
the svm method chooses the middle element from the widest set of parallel lines , that is , from the set in which the maximum distance between two elements in the set is highest .
it is noteworthy that this best decision surface is determined by only a small set of training examples , called the support vectors .
the method described is applicable also to the case in which the positives and the negatives are not linearly separable .
yang and liu [ 1999 ] experimentally compared the linear case ( namely , when the assumption is made that the categories are linearly separable ) with the nonlinear case on a standard benchmark , and obtained slightly better results in the former case .
as argued by joachims [ 1998 ] , svms offer two important advantages for tc : term selection is often not needed , as svms tend to be fairly robust to over- fitting and can scale up to considerable dimensionalities ; no human and machine effort in parameter tuning on a validation set is needed , as there is a theoretically motivated , default choice of parameter settings , which has also been shown to provide the best effectiveness .
dumais et al. [ 1998 ] have applied a novel algorithm for training svms which brings about training speeds comparable to computationally easy learners such as rocchio .
classifier committees .
classifier committees ( a.k.a. ensembles ) are based on the idea that , given a task that requires expert knowledge to perform , k experts may be better than one if their individual judgments are appropriately combined .
in tc , the idea is to apply k different classifiers o1 , ... , ok to the same task of deciding whether dj e ci , and then combine their outcome appropriately .
a classifier committee is then characterized by ( i ) a choice of k classifiers , and ( ii ) a choice of a combination function .
concerning issue ( i ) , it is known from the ml literature that , in order to guarantee good effectiveness , the classifiers forming the committee should be as independent as possible [ tumer and ghosh 1996 ] .
the classifiers may differ for the indexing approach used , or for the inductive method , or both .
within tc , the avenue which has been explored most is the latter ( to our knowledge the only example of the former is scott and matwin [ 1999 ] ) .
concerning issue ( ii ) , various rules have been tested .
the simplest one is majority voting ( mv ) , whereby the binary outputs of the k classifiers are pooled together , and the classification decision that reaches the majority of k21 votes is taken ( k obviously needs to be an odd number ) [ li and jain 1998 ; liere and tadepalli 1997 ] .
this method is particularly suited to the case in which the committee includes classifiers characterized by a binary decision function csvi : d -- > { t , f } .
a second rule is weighted linear combination ( wlc ) , whereby a weighted sum of the csvi s produced by the k classifiers yields the final csvi .
the weights wj reflect the expected relative effectiveness of classifiers oj , and are usually optimized on a validation set [ larkey and croft 1996 ] .
another policy is dynamic classifier selection ( dcs ) , whereby among committee { o1 , ... , ok } the classifier ot most effective on the l validation examples most similar to dj is selected , and its judgment adopted by the committee [ li and jain 1998 ] .
a still different policy , somehow intermediate between wlc and dcs , is adaptive classifier combination ( acc ) , whereby the judgments of all the classifiers in the committee are summed together , but their individual contribution is weighted by their effectiveness on the l validation examples most similar to dj [ li and jain 1998 ] .
classifier committees have had mixed results in tc so far .
larkey and croft [ 1996 ] have used combinations of rocchio , naive bayes , and k-nn , all together or in pairwise combinations , using a wlc rule .
in their experiments the combination of any two classifiers outperformed the best individual classifier ( k-nn ) , and the combination of the three classifiers improved an all three pairwise combinations .
these results would seem to give strong support to the idea that classifier committees can somehow profit from the complementary strengths of their individual members .
however , the small size of the test set used ( 187 documents ) suggests that more experimentation is needed before conclusions can be drawn .
li and jain [ 1998 ] have tested a committee formed of ( various combinations of ) a naive bayes classifier , an example-based classifier , a decision tree classifier , and a classifier built by means of their own subspace method ; the combination rules they have worked with are mv , dcs , and acc .
only in the case of a committee formed by naive bayes and the subspace classifier combined by means of acc has the committee outperformed , and by a narrow margin , the best individual classifier ( for every attempted classifier combination acc gave better results than mv and dcs ) .
this seems discouraging , especially in light of the fact that the committee approach is computationally expensive ( its cost trivially amounts to the sum of the costs of the individual classifiers plus the cost incurred for the computation of the combination rule ) .
again , it has to be remarked that the small size of their experiment ( two test sets of less than 700 documents each were used ) does not allow us to draw definitive conclusions on the approaches adopted .
boosting .
the boosting method [ schapire et al. 1998 ; schapire and singer 2000 ] occupies a special place in the classifier committees literature , since the k classifiers o1 , ... , ok forming the committee are obtained by the same learning method ( here called the weak learner ) .
the key intuition of boosting is that the k classifiers should be trained not in a conceptually parallel and independent way , as in the committees described above , but sequentially .
in this way , in training classifier oi one may take into account how classifiers o1 , ... , oi _ 1 perform on the training examples , and concentrate on getting right those examples on which o1 , ... , oi _ 1 have performed worst .
specifically , for learning classifier ot each ~ dj , ci ) pair is given an importance weight htij ( where h1 ijis set to be equal for all ( dj , ci ) pairs15 ) , which represents how hard to get a correct decision for this pair was for classifiers o1 , ... , ot _ 1 .
these weights are exploited in learning ot , which will be specially tuned to correctly solve the pairs with higher weight .
classifier ot is then applied to the training documents , and as a result weights ht ij are updated to htt 1 ; in this update operation , pairs correctly classified by ot will have their weight decreased , while pairs misclassified by ot will have their weight increased .
after all the k classifiers have been built , a weighted linear combination rule is applied to yield the final committee .
in the boostexter system [ schapire and singer 2000 ] , two different boosting algorithms are tested , using a one-level decision tree weak learner .
the former algorithm ( adaboost.mh , simply called adaboost in schapire et al. [ 1998 ] ) is explicitly geared toward the maximization of microaveraged effectiveness , whereas the latter ( adaboost.mr ) is aimed at minimizing ranking loss ( i.e. , at getting a correct category ranking for each individual document ) .
in experiments conducted over three different test collections , schapire et al. [ 1998 ] have shown adaboost to outperform sleeping experts , a classifier that had proven quite effective in the experiments of cohen and singer [ 1999 ] .
further experiments by schapire and singer [ 2000 ] showed adaboost to outperform , aside from sleeping experts , a naive bayes classifier , a standard ( nonenhanced ) rocchio classifier , and joachims [ 1997 ] prtfidf classifier .
a boosting algorithm based on a committee of classifier subcommittees that improves on the effectiveness and ( especially ) the efficiency of adaboost.mh was presented in sebastiani et al. [ 2000 ] .
an approach similar to boosting was also employed by weiss et al. [ 1999 ] , who experimented with committees of decision trees each having an average of 16 leaves ( and hence much more complex than the sim15 schapire et al. [ 1998 ] also showed that a simple modification of this policy allows optimization of the classifier based on utility ( see section 7.1.3 ) . ple decision stumps used in schapire and singer [ 2000 ] ) , eventually combined by using the simple mv rule as a combination rule ; similarly to boosting , a mechanism for emphasising documents that have been misclassified by previous decision trees is used .
boosting-based approaches have also been employed in escudero et al. [ 2000 ] , iyer et al. [ 2000 ] , kim et al. [ 2000 ] , li and jain [ 1998 ] , and myers et al. [ 2000 ] .
other methods .
although in the previous sections we have tried to give an overview as complete as possible of the learning approaches proposed in the tc literature , it is hardly possible to be exhaustive .
some of the learning approaches adopted do not fall squarely under one or the other class of algorithms , or have remained somehow isolated attempts .
among these , the most noteworthy are the ones based on bayesian inference networks [ dumais et al. 1998 ; lam et al. 1997 ; tzeras and hartmann 1993 ] , genetic algorithms [ clack et al. 1997 ; masand 1994 ] , and maximum entropy modelling [ manning and sch utze 1999 ] .
evaluation of text classifiers .
as for text search systems , the evaluation of document classifiers is typically conducted experimentally , rather than analytically .
the reason is that , in order to evaluate a system analytically ( e.g. , proving that the system is correct and complete ) , we would need a formal specification of the problem that the system is trying to solve ( e.g. , with respect to what correctness and completeness are defined ) , and the central notion of tc ( namely , that of membership of a document in a category ) is , due to its subjective character , inherently nonformalizable .
the experimental evaluation of a classifier usually measures its effectiveness ( rather than its efficiency ) , that is , its ability to take the right classification decisions .
measures of text categorization effectiveness .
precision and recall .
classification effectiveness is usually measured in terms of the classic ir notions of precision ( n ) and recall ( p ) , adapted to the case of tc .
precision wrt ci ( ni ) is defined as the conditional probability p ( ^ ~ ( dx , ci ) = t i ~ ( dx , ci ) = t ) , that is , as the probability that if a random document dx is classified under ci , this decision is correct .
analogously , recall wrt ci ( pi ) is defined as p ( 45 ( dx , ci ) = t i ^ ~ ( dx , ci ) = t ) , that is , as the probability that , if a random document dx ought to be classified under ci , this decision is taken .
these category- relative values may be averaged , in a way to be discussed shortly , to obtain n and p , that is , values global to the entire category set .
borrowing terminology from logic , n may be viewed as the degree of soundness of the classifier wrt c , while p may be viewed as its degree of completeness wrt c. as defined here , ni and pi are to be understood as subjective probabilities , that is , as measuring the expectation of the user that the system will behave correctly when classifying an unseen document under ci .
these probabilities may be estimated in terms of the contingency table for ci on a given test set ( see table ii ) .
here , fpi ( false positives wrt ci , a.k.a. errors of commission ) is the number of test documents incorrectly classified under ci ; tni ( true negatives wrt ci ) , tpi ( true positives wrt ci ) , and fni ( false negatives wrt ci , a.k.a. errors of omission ) are defined accordingly .
estimates ( indicated by carets ) of precision wrt ci and recall wrt ci may thus be obtained as for obtaining estimates of n and p , two different methods may be adopted : the reason is that , as yang [ 1999 ] pointed out , the large value that their denominator typically has in tc makes them much more insensitive to variations in the number of correct decisions ( tp + tn ) than n and p .
besides , if a is the adopted evaluation measure , in the frequent case of a very low average generality the trivial rejector ( i.e. , the classifier 4 ) such that 4 ) ( dj , ci ) = f for all dj and ci ) tends to outperform all nontrivial classifiers ( see also cohen [ 1995a ] , section 2.3 ) .
if a is adopted , parameter tuning on a validation set may thus result in parameter choices that make the classifier behave very much like the trivial rejector .
a nonstandard effectiveness measure was proposed by sable and hatzivassiloglou [ 2000 , section 7 ] , who suggested basing n and p not on absolute values of success and failure ( i.e. , 1 if 4 ) ( dj , ci ) = ^ 4 ) ( dj , ci ) and 0 if 4 ) ( dj , ci ) = ~ ^ 4 ) ( dj , ci ) ) , but on values of relative success ( i.e. , csvi ( dj ) if ^ 4 ) ( dj , ci ) = t and 1 csvi ( dj ) if ^ 4 ) ( dj , ci ) = f ) .
this means that for a correct ( respectively wrong ) decision the classifier is rewarded ( respectively penalized ) proportionally to its confidence in the decision .
this proposed measure does not reward the choice of a good thresholding policy , and is thus unfit for autonomous ( hard ) classification systems .
however , it might be appropriate for interactive ( ranking ) classifiers of the type used in larkey [ 1999 ] , where the confidence that the classifier has in its own decision influences category ranking and , as a consequence , the overall usefulness of the system . 7.1.3 .
measures alternative to effectiveness .
in general , criteria different from effectiveness are seldom used in classifier evaluation .
for instance , efficiency , although very important for applicative purposes , is seldom used as the sole yardstick , due to the volatility of the parameters on which the evaluation rests .
however , efficiency may be useful for choosing among classifiers with similar effectiveness .
an interesting evaluation has been carried out by dumais et al. [ 1998 ] , who have compared five different learning methods along three different dimensions , namely , effectiveness , training efficiency ( i.e. , the average time it takes to build a classifier for category ci from a training set tr ) , and classification efficiency ( i.e. , the average time it takes to classify a new document dj under category ci ) .
an important alternative to effectiveness is utility , a class of measures from decision theory that extend effectiveness by economic criteria such as gain or loss .
utility is based on a utility matrix such as that of table iv , where the numeric values utp , ufp , ufn and utn represent the gain brought about by a true positive , false positive , false negative , and true negative , respectively ; both utp and utn are greater than both ufp and ufn .
standard effectiveness is a special case of utility , i.e. , the one in which utp = utn > ufp = ufn .
less trivial cases are those in which utp = ~ utn and / or ufp = ~ ufn ; this is appropriate , for example , in spam filtering , where failing to discard a piece of junk mail ( fp ) is a less serious mistake than discarding a legitimate message ( fn ) [ androutsopoulos et al. 2000 ] .
if the classifier outputs probability estimates of the membership of dj in ci , then decision theory provides analytical methods to determine thresholds ri , thus avoiding the need to determine them experimentally ( as discussed in section 6.1 ) .
the use of utility in tc is discussed in detail by lewis [ 1955a ] .
other works where utility is employed are amati and crestani [ 1999 ] , cohen and singer [ 1999 ] , hull et al. [ 1996 ] , lewis and catlett [ 1994 ] , and schapire et al. [ 1998 ] .
utility has become popular within the text filtering community , and the trec filtering track evaluations have been using it for a while [ lewis 1995c ] .
the values of the utility matrix are extremely application- dependent .
this means that if utility is used instead of pure effectiveness , there is a further element of difficulty in the cross-comparison of classification systems ( see section 7.3 ) , since for two classifiers to be experimentally comparable also the two utility matrices must be the same .
other effectiveness measures different from the ones discussed here have occasionally been used in the literature ; these include adjacent score [ larkey 1998 ] , coverage [ schapire and singer 2000 ] , one- error [ schapire and singer 2000 ] , pearson product-moment correlation [ larkey 1998 ] , recall at n [ larkey and croft 1996 ] , top candidate [ larkey and croft 1996 ] , and top n [ larkey and croft 1996 ] .
we will not attempt to discuss them in detail .
however , their use shows that , although the tc community is making consistent efforts at standardizing experimentation protocols , we are still far from universal agreement on evaluation issues and , as a consequence , from understanding precisely the relative merits of the various methods .
combined effectiveness measures .
neither precision nor recall makes sense in isolation from each other .
in fact the classifier 4 ) such that 4 ) ( dj , ci ) = t for all dj and ci ( the trivial acceptor ) has p = 1 .
when the csvi function has values in [ 0 , 1 ] , one only needs to set every threshold ri to 0 to obtain the trivial acceptor . ( a ) with categories in place of ir queries .
this is most frequently used for document-ranking classifiers ( see sch utze et al. [ 1995 ] ; yang [ 1994 ] ; yang [ 1999 ] ; yang and pedersen [ 1997 ] ) ; ( b ) with test documents in place of ir queries and categories in place of documents .
this is most frequently used for category-ranking classifiers ( see lam et al. [ 1999 ] ; larkey and croft [ 1996 ] ; schapire and singer [ 2000 ] ; wiener et al. [ 1995 ] ) .
in this case , if macroaveraging is used , it needs to be redefined on a per-document , rather than per-category , basis .
this measure does not make sense for binary-valued csvi functions , since in this case pi may not be varied at will .
( 2 ) the breakeven point , that is , the value at which n equals p ( e.g. , apt e et al. [ 1994 ] ; cohen and singer [ 1999 ] ; dagan et al. [ 1997 ] ; joachims [ 1998 ] ; 17 while pi can always be increased at will by lowering ti , usually at the cost of decreasing ni , ni can usually be increased at will by raising ti , always at the cost of decreasing pi .
this kind of tuning is only possible for csvi functions with values in [ 0 , 1 ] ; for binary-valued csvi functions tuning is not always possible , or is anyway more difficult ( see weiss et al. [ 1999 ] , page 66 ) . 18 an exception is single-label tc , in which n and p are not independent of each other : if a document dj has been classified under a wrong category cs ( thus decreasing ns ) , this also means that it has not been classified under the right category ct ( thus decreasing pt ) .
in this case either n or p can be used as a measure of effectiveness .
joachims [ 1999 ] ; lewis [ 1992a ] ; lewis and ringuette [ 1994 ] ; moulinier and ganascia [ 1996 ] ; ng et al. [ 1997 ] ; yang [ 1999 ] ) .
this is obtained by a process analogous to the one used for 11-point average precision : a plot of n as a function of p is computed by repeatedly varying the thresholds ti ; breakeven is the value of p ( or n ) for which the plot intersects the p = n line .
this idea relies on the fact that , by decreasing the ti s from 1 to 0 , p always increases monotonically from 0 to 1 and n usually decreases monotonically from a value near 1 to | ~ | ~ i = 1 gte ( ci ) .
if for no values of the ti s n and p are exactly equal , the ti s are set to the value for which n and p are closest , and an interpolated breakeven is computed as the average of the values of n and p .
lewis himself ( see his message of 11 sep 1997 10 : 49 : 01 to the ddlbeta text categorization mailing list quoted with permission of the author ) has pointed out that breakeven is not a good effectiveness measure , since ( i ) there may be no parameter setting that yields the breakeven ; in this case the final breakeven value , obtained by interpolation , is artificial ; ( ii ) to have p equaln is not necessarily desirable , and it is not clear that a system that achieves high breakeven can be tuned to score high on other effectiveness measures .
yang [ 1999 ] also noted that when for no value of the parametersn and p are close enough , interpolated breakeven may not be a reliable indicator of effectiveness .
here p may be seen as the relative degree of importance attributed to n and p .
if p = 0 then ffl coincides with n , whereas if 0 = + oo then ffl coincides with p .
usually , a value 0 = 1 is used , which attributes equal importance to n and p .
as shown in moulinier et al. [ 1996 ] and yang [ 1999 ] , the breakeven of a classifier 4 ) is always less or equal than its f1 value .
once an effectiveness measure is chosen , a classifier can be tuned ( e.g. , thresholds and other parameters can be set ) so that the resulting effectiveness is the best achievable by that classifier .
tuning a parameter p ( be it a threshold or other ) is normally done experimentally .
this means performing repeated experiments on the validation set with the values of the other parameters pk fixed ( at a default value , in the case of a yet-tobe-tuned parameter pk , or at the chosen value , if the parameter pk has already been tuned ) and with different values for parameter p .
the value that has yielded the best effectiveness is chosen for p . 7.2 .
benchmarks for text categorization standard benchmark collections that can be used as initial corpora for tc are publically available for experimental purposes .
the most widely used is the reuters collection , consisting of a set of newswire stories classified under categories related to economics .
the reuters collection accounts for most of the experimental work in tc so far .
unfortunately , this does not always translate into reliable comparative results , in the sense that many of these experiments have been carried out in subtly different conditions .
in general , different sets of experiments may be used for cross-classifier comparison only if the experiments have been performed ( 1 ) on exactly the same collection ( i.e. , same documents and same categories ) ; ( 2 ) with the same split between training set and test set ; ( 3 ) with the same evaluation measure and , whenever this measure depends on some parameters ( e.g. , the utility matrix chosen ) , with the same parameter values .
unfortunately , a lot of experimentation , both on reuters and on other collections , has not been performed with these caveats in mind : by testing three different classifiers on five popular versions of reuters , yang [ 1999 ] has shown that a lack of compliance with these three conditions may make the experimental results hardly comparable among each other .
table vi lists the results of all experiments known to us performed on five major versions of the reuters benchmark : reuters-22173 modlewis ( column # 1 ) , reuters-22173 modapt e ( column # 2 ) , reuters-22173 modwiener ( column # 3 ) , reuters-21578 modapt e ( column # 4 ) , and reuters-21578 [ 10 ] modapt e ( column # 5 ) .20 only experiments that have computed either a breakeven or f1 have been listed , since other less popular effectiveness measures do not readily compare with these .
note that only results belonging to the same column are directly comparable .
in particular , yang [ 1999 ] showed that experiments carried out on reuters-22173 modlewis ( column # 1 ) are not directly comparable with those using the other three versions , since the former strangely includes a significant percentage ( 58 % ) of unlabeled test documents which , being negative examples of all categories , tend to depress effectiveness .
also , experiments performed on reuters-21578 [ 10 ] modapt e ( column # 5 ) are not comparable with the others , since this collection is the restriction of reuters-21578 modapt e to the 10 categories with the highest generality , and is thus an obviously easier collection .
other test collections that have been frequently used are the ohsumed collection , set up by hersh et al. [ 1994 ] and used by joachims [ 1998 ] , lam and ho [ 1998 ] , lam et al. [ 1999 ] , lewis et al. [ 1996 ] , ruiz and srinivasan [ 1999 ] , and yang [ 2000 ] , and schapire and singer [ 2000 ] .
the documents are messages posted to usenet newsgroups , and the categories are the newsgroups themselves .
we will not cover the experiments performed on these collections for the same reasons as those illustrated in footnote 20 , that is , because in no case have a significant enough number of authors used the same collection in the same experimental conditions , thus making comparisons difficult .
which text classifier is best ? .
the published experimental results , and especially those listed in table vi , allow us to attempt some considerations on the comparative performance of the tc methods discussed .
however , we have to bear in mind that comparisons are reliable only when based on experiments performed by the same author under carefully controlled conditions .
they are instead more problematic when they involve different experiments performed by different authors .
in this case various background conditions , often extraneous to the learning algorithm itself , may influence the results .
these may include , among others , different choices in preprocessing ( stemming , etc . ) , indexing , dimensionality reduction , classifier parameter values , etc . , but also different standards of compliance with safe scientific practice ( such as tuning parameters on the test set rather than on a separate validation set ) , which often are not discussed in the published papers .
a number of interesting conclusions can be drawn from table vi by using these two boosting-based classifier committees , support vector machines , example-based methods , and regression methods deliver top-notch performance .
there seems to be no sufficient evidence to decidedly opt for either method ; efficiency considerations or application- dependent issues might play a role in breaking the tie .
neural networks and on-line linear classifiers work very well , although slightly worse than the previously mentioned methods .
batch linear classifiers ( rocchio ) and probabilistic naive bayes classifiers look the worst of the learning-based classifiers .
for rocchio , these results confirm earlier results by sch utze et al. [ 1995 ] , who had found three classifiers based on linear discriminant analysis , linear regression , and neural networks to perform about 15 % better than rocchio .
however , recent results by schapire et al. [ 1998 ] ranked rocchio along the best performers once near- positives are used in training .
the data in table vi is hardly sufficient to say anything about decision trees .
however , the work by dumais et al. [ 1998 ] , in which a decision tree classifier was shown to perform nearly as well as their top performing system ( a svm classifier ) , will probably renew the interest in decision trees , an interest that had dwindled after the unimpressive results reported in earlier literature [ cohen and singer 1999 ; joachims 1998 ; lewis and catlett 1994 ; lewis and ringuette 1994 ] .
by far the lowest performance is displayed by word , a classifier implemented by yang [ 1999 ] and not including any learning component.22 concerning word and no-learning classifiers , for completeness we should recall that one of the highest effectiveness values reported in the literature for the reuters collection ( a .90 breakeven ) belongs to construe , a manually constructed classifier .
however , this classifier has never been tested on the standard variants of reuters mentioned in table vi , and it is not clear [ yang 1999 ] whether the ( small ) test set of reuters-22173 modhayes on 22 word is based on the comparison between documents and category names , each treated as a vector of weighted terms in the vector space model .
word was implemented by yang with the only purpose of determining the difference in effectiveness that adding a learning component to a classifier brings about .
word is actually called str in [ yang 1994 ; yang and chute 1994 ] .
another no-learning classifier was proposed in wong et al. [ 1996 ] . which the .90 breakeven value was obtained was chosen randomly , as safe scientific practice would demand .
therefore , the fact that this figure is indicative of the performance of construe , and of the manual approach it represents , has been convincingly questioned [ yang 1999 ] .
it is important to bear in mind that the considerations above are not absolute statements ( if there may be any ) on the comparative effectiveness of these tc methods .
one of the reasons is that a particular applicative context may exhibit very different characteristics from the ones to be found in reuters , and different classifiers may respond differently to these characteristics .
an experimental study by joachims [ 1998 ] involving support vector machines , k-nn , decision trees , rocchio , and naive bayes , showed all these classifiers to have similar effectiveness on categories with > 300 positive training examples each .
the fact that this experiment involved the methods which have scored best ( support vector machines , k-nn ) and worst ( rocchio and naive bayes ) according to table vi shows that applicative contexts different from reuters may well invalidate conclusions drawn on this latter .
finally , a note about the worth of statistical significance testing .
few authors have gone to the trouble of validating their results by means of such tests .
these tests are useful for verifying how strongly the experimental results support the claim that a given system 45 ' is better than another system 45 " , or for verifying how much a difference in the experimental setup affects the measured effectiveness of a system 4 ) .
hull [ 1994 ] and sch utze et al. [ 1995 ] have been among the first to work in this direction , validating their results by means of the anova test and the friedman test ; the former is aimed at determining the significance of the difference in effectiveness between two methods in terms of the ratio between this difference and the effectiveness variability across categories , while the latter conducts a similar test by using instead the rank positions of each method within a category .
yang and liu [ 1999 ] defined a full suite of significance tests , some of which apply to microaveraged and some to macroaveraged effectiveness .
they applied them systematically to the comparison between five different classifiers , and were thus able to infer fine- grained conclusions about their relative effectiveness .
for other examples of significance testing in tc , see cohen [ 1995a , 1995b ] ; cohen and hirsh [ 1998 ] , joachims [ 1997 ] , koller and sahami [ 1997 ] , lewis et al. [ 1996 ] , and wiener et al. [ 1995 ] .
conclusion .
automated tc is now a major research area within the information systems discipline , thanks to a number of factors : its domains of application are numerous and important , and given the proliferation of documents in digital form they are bound to increase dramatically in both number and importance .
it is indispensable in many applications in which the sheer number of the documents to be classified and the short response time required by the application make the manual alternative implausible .
it can improve the productivity of human classifiers in applications in which no classification decision can be taken without a final human judgment [ larkey and croft 1996 ] , by providing tools that quickly suggest plausible decisions .
it has reached effectiveness levels comparable to those of trained professionals .
the effectiveness of manual tc is not 100 % anyway [ cleverdon 1984 ] and , more importantly , it is unlikely to be improved substantially by the progress of research .
the levels of effectiveness of automated tc are instead growing at a steady pace , and even if they will likely reach a plateau well below the 100 % level , this plateau will probably be higher than the effectiveness levels of manual tc .
one of the reasons why from the early 90s the effectiveness of text classifiers has dramatically improved is the arrival in the tc arena of ml methods that are backed by strong theoretical motivations .
examples of these are multiplicative weight updating ( e.g. , the winnow family , widrow-hoff , etc . ) , adaptive re- sampling ( e.g. , boosting ) , and support vector machines , which provide a sharp contrast with relatively unsophisticated and weak methods such as rocchio .
in tc , ml researchers have found a challenging application , since datasets consisting of hundreds of thousands of documents and characterized by tens of thousands of terms are widely available .
this means that tc is a good benchmark for checking whether a given learning technique can scale up to substantial sizes .
in turn , this probably means that the active involvement of the ml community in tc is bound to grow .
the success story of automated tc is also going to encourage an extension of its methods and techniques to neighboring fields of application .
techniques typical of automated tc have already been extended successfully to the categorization of documents expressed in slightly different media ; for instance : very noisy text resulting from optical character recognition [ ittner et al. 1995 ; junker and hoch 1998 ] .
in their experiments ittner et al. [ 1995 ] have found that , by employing noisy texts also in the training phase ( i.e. texts affected by the same source of noise that is also at work in the test documents ) , effectiveness levels comparable to those obtainable in the case of standard text can be achieved. speech transcripts [ myers et al. 2000 ; schapire and singer 2000 ] .
for instance , schapire and singer [ 2000 ] classified answers given to a phone operator s request how may i help you ? so as to be able to route the call to a specialized operator according to call type .
concerning other more radically different media , the situation is not as bright ( however , see lim [ 1999 ] for an interesting attempt at image categorization based on a textual metaphor ) .
the reason for this is that capturing real semantic content of nontextual media by automatic indexing is still an open problem .
while there are systems that attempt to detect content , for example , in images by recognizing shapes , color distributions , and texture , the general problem of image semantics is still unsolved .
the main reason is that natural language , the language of the text medium , admits far fewer variations than the languages employed by the other media .
for instance , while the concept of a house can be triggered by relatively few natural language expressions such as house , houses , home , housing , inhabiting , etc . , it can be triggered by far more images : the images of all the different houses that exist , of all possible colors and shapes , viewed from all possible perspectives , from all possible distances , etc .
if we had solved the multimedia indexing problem in a satisfactory way , the general methodology that we have discussed in this paper for text would also apply to automated multimedia categorization , and there are reasons to believe that the effectiveness levels could be as high .
this only adds to the common sentiment that more research in automated content- based indexing for multimedia documents is needed .
